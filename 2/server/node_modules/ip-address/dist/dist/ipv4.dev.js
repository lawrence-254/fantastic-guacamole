"use strict";
/* eslint-disable no-param-reassign */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Address4 = void 0;

var common = __importStar(require("./common"));

var constants = __importStar(require("./v4/constants"));

var address_error_1 = require("./address-error");

var jsbn_1 = require("jsbn");

var sprintf_js_1 = require("sprintf-js");
/**
 * Represents an IPv4 address
 * @class Address4
 * @param {string} address - An IPv4 address string
 */


var Address4 =
/*#__PURE__*/
function () {
  function Address4(address) {
    _classCallCheck(this, Address4);

    this.groups = constants.GROUPS;
    this.parsedAddress = [];
    this.parsedSubnet = '';
    this.subnet = '/32';
    this.subnetMask = 32;
    this.v4 = true;
    /**
     * Returns true if the address is correct, false otherwise
     * @memberof Address4
     * @instance
     * @returns {Boolean}
     */

    this.isCorrect = common.isCorrect(constants.BITS);
    /**
     * Returns true if the given address is in the subnet of the current address
     * @memberof Address4
     * @instance
     * @returns {boolean}
     */

    this.isInSubnet = common.isInSubnet;
    this.address = address;
    var subnet = constants.RE_SUBNET_STRING.exec(address);

    if (subnet) {
      this.parsedSubnet = subnet[0].replace('/', '');
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = "/".concat(this.subnetMask);

      if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
        throw new address_error_1.AddressError('Invalid subnet mask.');
      }

      address = address.replace(constants.RE_SUBNET_STRING, '');
    }

    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(address);
  }

  _createClass(Address4, [{
    key: "parse",

    /*
     * Parses a v4 address
     */
    value: function parse(address) {
      var groups = address.split('.');

      if (!address.match(constants.RE_ADDRESS)) {
        throw new address_error_1.AddressError('Invalid IPv4 address.');
      }

      return groups;
    }
    /**
     * Returns the correct form of an address
     * @memberof Address4
     * @instance
     * @returns {String}
     */

  }, {
    key: "correctForm",
    value: function correctForm() {
      return this.parsedAddress.map(function (part) {
        return parseInt(part, 10);
      }).join('.');
    }
    /**
     * Converts a hex string to an IPv4 address object
     * @memberof Address4
     * @static
     * @param {string} hex - a hex string to convert
     * @returns {Address4}
     */

  }, {
    key: "toHex",

    /**
     * Converts an IPv4 address object to a hex string
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    value: function toHex() {
      return this.parsedAddress.map(function (part) {
        return (0, sprintf_js_1.sprintf)('%02x', parseInt(part, 10));
      }).join(':');
    }
    /**
     * Converts an IPv4 address object to an array of bytes
     * @memberof Address4
     * @instance
     * @returns {Array}
     */

  }, {
    key: "toArray",
    value: function toArray() {
      return this.parsedAddress.map(function (part) {
        return parseInt(part, 10);
      });
    }
    /**
     * Converts an IPv4 address object to an IPv6 address group
     * @memberof Address4
     * @instance
     * @returns {String}
     */

  }, {
    key: "toGroup6",
    value: function toGroup6() {
      var output = [];
      var i;

      for (i = 0; i < constants.GROUPS; i += 2) {
        var hex = (0, sprintf_js_1.sprintf)('%02x%02x', parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
        output.push((0, sprintf_js_1.sprintf)('%x', parseInt(hex, 16)));
      }

      return output.join(':');
    }
    /**
     * Returns the address as a BigInteger
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "bigInteger",
    value: function bigInteger() {
      return new jsbn_1.BigInteger(this.parsedAddress.map(function (n) {
        return (0, sprintf_js_1.sprintf)('%02x', parseInt(n, 10));
      }).join(''), 16);
    }
    /**
     * Helper function getting start address.
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "_startAddress",
    value: function _startAddress() {
      return new jsbn_1.BigInteger(this.mask() + '0'.repeat(constants.BITS - this.subnetMask), 2);
    }
    /**
     * The first address in the range given by this address' subnet.
     * Often referred to as the Network Address.
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "startAddress",
    value: function startAddress() {
      return Address4.fromBigInteger(this._startAddress());
    }
    /**
     * The first host address in the range given by this address's subnet ie
     * the first address after the Network Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "startAddressExclusive",
    value: function startAddressExclusive() {
      var adjust = new jsbn_1.BigInteger('1');
      return Address4.fromBigInteger(this._startAddress().add(adjust));
    }
    /**
     * Helper function getting end address.
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "_endAddress",
    value: function _endAddress() {
      return new jsbn_1.BigInteger(this.mask() + '1'.repeat(constants.BITS - this.subnetMask), 2);
    }
    /**
     * The last address in the range given by this address' subnet
     * Often referred to as the Broadcast
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "endAddress",
    value: function endAddress() {
      return Address4.fromBigInteger(this._endAddress());
    }
    /**
     * The last host address in the range given by this address's subnet ie
     * the last address prior to the Broadcast Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "endAddressExclusive",
    value: function endAddressExclusive() {
      var adjust = new jsbn_1.BigInteger('1');
      return Address4.fromBigInteger(this._endAddress().subtract(adjust));
    }
    /**
     * Converts a BigInteger to a v4 address object
     * @memberof Address4
     * @static
     * @param {BigInteger} bigInteger - a BigInteger to convert
     * @returns {Address4}
     */

  }, {
    key: "mask",

    /**
     * Returns the first n bits of the address, defaulting to the
     * subnet mask
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    value: function mask(_mask) {
      if (_mask === undefined) {
        _mask = this.subnetMask;
      }

      return this.getBitsBase2(0, _mask);
    }
    /**
     * Returns the bits in the given range as a base-2 string
     * @memberof Address4
     * @instance
     * @returns {string}
     */

  }, {
    key: "getBitsBase2",
    value: function getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    /**
     * Return the reversed ip6.arpa form of the address
     * @memberof Address4
     * @param {Object} options
     * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
     * @instance
     * @returns {String}
     */

  }, {
    key: "reverseForm",
    value: function reverseForm(options) {
      if (!options) {
        options = {};
      }

      var reversed = this.correctForm().split('.').reverse().join('.');

      if (options.omitSuffix) {
        return reversed;
      }

      return (0, sprintf_js_1.sprintf)('%s.in-addr.arpa.', reversed);
    }
    /**
     * Returns true if the given address is a multicast address
     * @memberof Address4
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "isMulticast",
    value: function isMulticast() {
      return this.isInSubnet(new Address4('224.0.0.0/4'));
    }
    /**
     * Returns a zero-padded base-2 string representation of the address
     * @memberof Address4
     * @instance
     * @returns {string}
     */

  }, {
    key: "binaryZeroPad",
    value: function binaryZeroPad() {
      return this.bigInteger().toString(2).padStart(constants.BITS, '0');
    }
    /**
     * Groups an IPv4 address for inclusion at the end of an IPv6 address
     * @returns {String}
     */

  }, {
    key: "groupForV6",
    value: function groupForV6() {
      var segments = this.parsedAddress;
      return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join('.'), segments.slice(2, 4).join('.')));
    }
  }], [{
    key: "isValid",
    value: function isValid(address) {
      try {
        // eslint-disable-next-line no-new
        new Address4(address);
        return true;
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      var padded = hex.replace(/:/g, '').padStart(8, '0');
      var groups = [];
      var i;

      for (i = 0; i < 8; i += 2) {
        var h = padded.slice(i, i + 2);
        groups.push(parseInt(h, 16));
      }

      return new Address4(groups.join('.'));
    }
    /**
     * Converts an integer into a IPv4 address object
     * @memberof Address4
     * @static
     * @param {integer} integer - a number to convert
     * @returns {Address4}
     */

  }, {
    key: "fromInteger",
    value: function fromInteger(integer) {
      return Address4.fromHex(integer.toString(16));
    }
    /**
     * Return an address from in-addr.arpa form
     * @memberof Address4
     * @static
     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
     * @returns {Adress4}
     * @example
     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
     * address.correctForm(); // '192.0.2.42'
     */

  }, {
    key: "fromArpa",
    value: function fromArpa(arpaFormAddress) {
      // remove ending ".in-addr.arpa." or just "."
      var leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, '');
      var address = leader.split('.').reverse().join('.');
      return new Address4(address);
    }
  }, {
    key: "fromBigInteger",
    value: function fromBigInteger(bigInteger) {
      return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
    }
  }]);

  return Address4;
}();

exports.Address4 = Address4;