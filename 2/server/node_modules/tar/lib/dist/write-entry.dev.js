'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('minipass'),
    Minipass = _require.Minipass;

var Pax = require('./pax.js');

var Header = require('./header.js');

var fs = require('fs');

var path = require('path');

var normPath = require('./normalize-windows-path.js');

var stripSlash = require('./strip-trailing-slashes.js');

var prefixPath = function prefixPath(path, prefix) {
  if (!prefix) {
    return normPath(path);
  }

  path = normPath(path).replace(/^\.(\/|$)/, '');
  return stripSlash(prefix) + '/' + path;
};

var maxReadSize = 16 * 1024 * 1024;
var PROCESS = Symbol('process');
var FILE = Symbol('file');
var DIRECTORY = Symbol('directory');
var SYMLINK = Symbol('symlink');
var HARDLINK = Symbol('hardlink');
var HEADER = Symbol('header');
var READ = Symbol('read');
var LSTAT = Symbol('lstat');
var ONLSTAT = Symbol('onlstat');
var ONREAD = Symbol('onread');
var ONREADLINK = Symbol('onreadlink');
var OPENFILE = Symbol('openfile');
var ONOPENFILE = Symbol('onopenfile');
var CLOSE = Symbol('close');
var MODE = Symbol('mode');
var AWAITDRAIN = Symbol('awaitDrain');
var ONDRAIN = Symbol('ondrain');
var PREFIX = Symbol('prefix');
var HAD_ERROR = Symbol('hadError');

var warner = require('./warn-mixin.js');

var winchars = require('./winchars.js');

var stripAbsolutePath = require('./strip-absolute-path.js');

var modeFix = require('./mode-fix.js');

var WriteEntry = warner(
/*#__PURE__*/
function (_Minipass) {
  _inherits(WriteEntry, _Minipass);

  function WriteEntry(p, opt) {
    var _this;

    _classCallCheck(this, WriteEntry);

    opt = opt || {};
    _this = _possibleConstructorReturn(this, _getPrototypeOf(WriteEntry).call(this, opt));

    if (typeof p !== 'string') {
      throw new TypeError('path is required');
    }

    _this.path = normPath(p); // suppress atime, ctime, uid, gid, uname, gname

    _this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do

    _this.myuid = process.getuid && process.getuid() || 0;
    _this.myuser = process.env.USER || '';
    _this.maxReadSize = opt.maxReadSize || maxReadSize;
    _this.linkCache = opt.linkCache || new Map();
    _this.statCache = opt.statCache || new Map();
    _this.preservePaths = !!opt.preservePaths;
    _this.cwd = normPath(opt.cwd || process.cwd());
    _this.strict = !!opt.strict;
    _this.noPax = !!opt.noPax;
    _this.noMtime = !!opt.noMtime;
    _this.mtime = opt.mtime || null;
    _this.prefix = opt.prefix ? normPath(opt.prefix) : null;
    _this.fd = null;
    _this.blockLen = null;
    _this.blockRemain = null;
    _this.buf = null;
    _this.offset = null;
    _this.length = null;
    _this.pos = null;
    _this.remain = null;

    if (typeof opt.onwarn === 'function') {
      _this.on('warn', opt.onwarn);
    }

    var pathWarn = false;

    if (!_this.preservePaths) {
      var _stripAbsolutePath = stripAbsolutePath(_this.path),
          _stripAbsolutePath2 = _slicedToArray(_stripAbsolutePath, 2),
          root = _stripAbsolutePath2[0],
          stripped = _stripAbsolutePath2[1];

      if (root) {
        _this.path = stripped;
        pathWarn = root;
      }
    }

    _this.win32 = !!opt.win32 || process.platform === 'win32';

    if (_this.win32) {
      // force the \ to / normalization, since we might not *actually*
      // be on windows, but want \ to be considered a path separator.
      _this.path = winchars.decode(_this.path.replace(/\\/g, '/'));
      p = p.replace(/\\/g, '/');
    }

    _this.absolute = normPath(opt.absolute || path.resolve(_this.cwd, p));

    if (_this.path === '') {
      _this.path = './';
    }

    if (pathWarn) {
      _this.warn('TAR_ENTRY_INFO', "stripping ".concat(pathWarn, " from absolute path"), {
        entry: _assertThisInitialized(_this),
        path: pathWarn + _this.path
      });
    }

    if (_this.statCache.has(_this.absolute)) {
      _this[ONLSTAT](_this.statCache.get(_this.absolute));
    } else {
      _this[LSTAT]();
    }

    return _this;
  }

  _createClass(WriteEntry, [{
    key: "emit",
    value: function emit(ev) {
      var _get2;

      if (ev === 'error') {
        this[HAD_ERROR] = true;
      }

      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf(WriteEntry.prototype), "emit", this)).call.apply(_get2, [this, ev].concat(data));
    }
  }, {
    key: LSTAT,
    value: function value() {
      var _this2 = this;

      fs.lstat(this.absolute, function (er, stat) {
        if (er) {
          return _this2.emit('error', er);
        }

        _this2[ONLSTAT](stat);
      });
    }
  }, {
    key: ONLSTAT,
    value: function value(stat) {
      this.statCache.set(this.absolute, stat);
      this.stat = stat;

      if (!stat.isFile()) {
        stat.size = 0;
      }

      this.type = getType(stat);
      this.emit('stat', stat);
      this[PROCESS]();
    }
  }, {
    key: PROCESS,
    value: function value() {
      switch (this.type) {
        case 'File':
          return this[FILE]();

        case 'Directory':
          return this[DIRECTORY]();

        case 'SymbolicLink':
          return this[SYMLINK]();
        // unsupported types are ignored.

        default:
          return this.end();
      }
    }
  }, {
    key: MODE,
    value: function value(mode) {
      return modeFix(mode, this.type === 'Directory', this.portable);
    }
  }, {
    key: PREFIX,
    value: function value(path) {
      return prefixPath(path, this.prefix);
    }
  }, {
    key: HEADER,
    value: function value() {
      if (this.type === 'Directory' && this.portable) {
        this.noMtime = true;
      }

      this.header = new Header({
        path: this[PREFIX](this.path),
        // only apply the prefix to hard links.
        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      });

      if (this.header.encode() && !this.noPax) {
        _get(_getPrototypeOf(WriteEntry.prototype), "write", this).call(this, new Pax({
          atime: this.portable ? null : this.header.atime,
          ctime: this.portable ? null : this.header.ctime,
          gid: this.portable ? null : this.header.gid,
          mtime: this.noMtime ? null : this.mtime || this.header.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.header.size,
          uid: this.portable ? null : this.header.uid,
          uname: this.portable ? null : this.header.uname,
          dev: this.portable ? null : this.stat.dev,
          ino: this.portable ? null : this.stat.ino,
          nlink: this.portable ? null : this.stat.nlink
        }).encode());
      }

      _get(_getPrototypeOf(WriteEntry.prototype), "write", this).call(this, this.header.block);
    }
  }, {
    key: DIRECTORY,
    value: function value() {
      if (this.path.slice(-1) !== '/') {
        this.path += '/';
      }

      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
  }, {
    key: SYMLINK,
    value: function value() {
      var _this3 = this;

      fs.readlink(this.absolute, function (er, linkpath) {
        if (er) {
          return _this3.emit('error', er);
        }

        _this3[ONREADLINK](linkpath);
      });
    }
  }, {
    key: ONREADLINK,
    value: function value(linkpath) {
      this.linkpath = normPath(linkpath);
      this[HEADER]();
      this.end();
    }
  }, {
    key: HARDLINK,
    value: function value(linkpath) {
      this.type = 'Link';
      this.linkpath = normPath(path.relative(this.cwd, linkpath));
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
  }, {
    key: FILE,
    value: function value() {
      if (this.stat.nlink > 1) {
        var linkKey = this.stat.dev + ':' + this.stat.ino;

        if (this.linkCache.has(linkKey)) {
          var linkpath = this.linkCache.get(linkKey);

          if (linkpath.indexOf(this.cwd) === 0) {
            return this[HARDLINK](linkpath);
          }
        }

        this.linkCache.set(linkKey, this.absolute);
      }

      this[HEADER]();

      if (this.stat.size === 0) {
        return this.end();
      }

      this[OPENFILE]();
    }
  }, {
    key: OPENFILE,
    value: function value() {
      var _this4 = this;

      fs.open(this.absolute, 'r', function (er, fd) {
        if (er) {
          return _this4.emit('error', er);
        }

        _this4[ONOPENFILE](fd);
      });
    }
  }, {
    key: ONOPENFILE,
    value: function value(fd) {
      this.fd = fd;

      if (this[HAD_ERROR]) {
        return this[CLOSE]();
      }

      this.blockLen = 512 * Math.ceil(this.stat.size / 512);
      this.blockRemain = this.blockLen;
      var bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen);
      this.offset = 0;
      this.pos = 0;
      this.remain = this.stat.size;
      this.length = this.buf.length;
      this[READ]();
    }
  }, {
    key: READ,
    value: function value() {
      var _this5 = this;

      var fd = this.fd,
          buf = this.buf,
          offset = this.offset,
          length = this.length,
          pos = this.pos;
      fs.read(fd, buf, offset, length, pos, function (er, bytesRead) {
        if (er) {
          // ignoring the error from close(2) is a bad practice, but at
          // this point we already have an error, don't need another one
          return _this5[CLOSE](function () {
            return _this5.emit('error', er);
          });
        }

        _this5[ONREAD](bytesRead);
      });
    }
  }, {
    key: CLOSE,
    value: function value(cb) {
      fs.close(this.fd, cb);
    }
  }, {
    key: ONREAD,
    value: function value(bytesRead) {
      var _this6 = this;

      if (bytesRead <= 0 && this.remain > 0) {
        var er = new Error('encountered unexpected EOF');
        er.path = this.absolute;
        er.syscall = 'read';
        er.code = 'EOF';
        return this[CLOSE](function () {
          return _this6.emit('error', er);
        });
      }

      if (bytesRead > this.remain) {
        var _er = new Error('did not encounter expected EOF');

        _er.path = this.absolute;
        _er.syscall = 'read';
        _er.code = 'EOF';
        return this[CLOSE](function () {
          return _this6.emit('error', _er);
        });
      } // null out the rest of the buffer, if we could fit the block padding
      // at the end of this loop, we've incremented bytesRead and this.remain
      // to be incremented up to the blockRemain level, as if we had expected
      // to get a null-padded file, and read it until the end.  then we will
      // decrement both remain and blockRemain by bytesRead, and know that we
      // reached the expected EOF, without any null buffer to append.


      if (bytesRead === this.remain) {
        for (var i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
          this.buf[i + this.offset] = 0;
          bytesRead++;
          this.remain++;
        }
      }

      var writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
      var flushed = this.write(writeBuf);

      if (!flushed) {
        this[AWAITDRAIN](function () {
          return _this6[ONDRAIN]();
        });
      } else {
        this[ONDRAIN]();
      }
    }
  }, {
    key: AWAITDRAIN,
    value: function value(cb) {
      this.once('drain', cb);
    }
  }, {
    key: "write",
    value: function write(writeBuf) {
      if (this.blockRemain < writeBuf.length) {
        var er = new Error('writing more data than expected');
        er.path = this.absolute;
        return this.emit('error', er);
      }

      this.remain -= writeBuf.length;
      this.blockRemain -= writeBuf.length;
      this.pos += writeBuf.length;
      this.offset += writeBuf.length;
      return _get(_getPrototypeOf(WriteEntry.prototype), "write", this).call(this, writeBuf);
    }
  }, {
    key: ONDRAIN,
    value: function value() {
      var _this7 = this;

      if (!this.remain) {
        if (this.blockRemain) {
          _get(_getPrototypeOf(WriteEntry.prototype), "write", this).call(this, Buffer.alloc(this.blockRemain));
        }

        return this[CLOSE](function (er) {
          return er ? _this7.emit('error', er) : _this7.end();
        });
      }

      if (this.offset >= this.length) {
        // if we only have a smaller bit left to read, alloc a smaller buffer
        // otherwise, keep it the same length it was before.
        this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
        this.offset = 0;
      }

      this.length = this.buf.length - this.offset;
      this[READ]();
    }
  }]);

  return WriteEntry;
}(Minipass));

var WriteEntrySync =
/*#__PURE__*/
function (_WriteEntry) {
  _inherits(WriteEntrySync, _WriteEntry);

  function WriteEntrySync() {
    _classCallCheck(this, WriteEntrySync);

    return _possibleConstructorReturn(this, _getPrototypeOf(WriteEntrySync).apply(this, arguments));
  }

  _createClass(WriteEntrySync, [{
    key: LSTAT,
    value: function value() {
      this[ONLSTAT](fs.lstatSync(this.absolute));
    }
  }, {
    key: SYMLINK,
    value: function value() {
      this[ONREADLINK](fs.readlinkSync(this.absolute));
    }
  }, {
    key: OPENFILE,
    value: function value() {
      this[ONOPENFILE](fs.openSync(this.absolute, 'r'));
    }
  }, {
    key: READ,
    value: function value() {
      var threw = true;

      try {
        var fd = this.fd,
            buf = this.buf,
            offset = this.offset,
            length = this.length,
            pos = this.pos;
        var bytesRead = fs.readSync(fd, buf, offset, length, pos);
        this[ONREAD](bytesRead);
        threw = false;
      } finally {
        // ignoring the error from close(2) is a bad practice, but at
        // this point we already have an error, don't need another one
        if (threw) {
          try {
            this[CLOSE](function () {});
          } catch (er) {}
        }
      }
    }
  }, {
    key: AWAITDRAIN,
    value: function value(cb) {
      cb();
    }
  }, {
    key: CLOSE,
    value: function value(cb) {
      fs.closeSync(this.fd);
      cb();
    }
  }]);

  return WriteEntrySync;
}(WriteEntry);

var WriteEntryTar = warner(
/*#__PURE__*/
function (_Minipass2) {
  _inherits(WriteEntryTar, _Minipass2);

  function WriteEntryTar(readEntry, opt) {
    var _this8;

    _classCallCheck(this, WriteEntryTar);

    opt = opt || {};
    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(WriteEntryTar).call(this, opt));
    _this8.preservePaths = !!opt.preservePaths;
    _this8.portable = !!opt.portable;
    _this8.strict = !!opt.strict;
    _this8.noPax = !!opt.noPax;
    _this8.noMtime = !!opt.noMtime;
    _this8.readEntry = readEntry;
    _this8.type = readEntry.type;

    if (_this8.type === 'Directory' && _this8.portable) {
      _this8.noMtime = true;
    }

    _this8.prefix = opt.prefix || null;
    _this8.path = normPath(readEntry.path);
    _this8.mode = _this8[MODE](readEntry.mode);
    _this8.uid = _this8.portable ? null : readEntry.uid;
    _this8.gid = _this8.portable ? null : readEntry.gid;
    _this8.uname = _this8.portable ? null : readEntry.uname;
    _this8.gname = _this8.portable ? null : readEntry.gname;
    _this8.size = readEntry.size;
    _this8.mtime = _this8.noMtime ? null : opt.mtime || readEntry.mtime;
    _this8.atime = _this8.portable ? null : readEntry.atime;
    _this8.ctime = _this8.portable ? null : readEntry.ctime;
    _this8.linkpath = normPath(readEntry.linkpath);

    if (typeof opt.onwarn === 'function') {
      _this8.on('warn', opt.onwarn);
    }

    var pathWarn = false;

    if (!_this8.preservePaths) {
      var _stripAbsolutePath3 = stripAbsolutePath(_this8.path),
          _stripAbsolutePath4 = _slicedToArray(_stripAbsolutePath3, 2),
          root = _stripAbsolutePath4[0],
          stripped = _stripAbsolutePath4[1];

      if (root) {
        _this8.path = stripped;
        pathWarn = root;
      }
    }

    _this8.remain = readEntry.size;
    _this8.blockRemain = readEntry.startBlockSize;
    _this8.header = new Header({
      path: _this8[PREFIX](_this8.path),
      linkpath: _this8.type === 'Link' ? _this8[PREFIX](_this8.linkpath) : _this8.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: _this8.mode,
      uid: _this8.portable ? null : _this8.uid,
      gid: _this8.portable ? null : _this8.gid,
      size: _this8.size,
      mtime: _this8.noMtime ? null : _this8.mtime,
      type: _this8.type,
      uname: _this8.portable ? null : _this8.uname,
      atime: _this8.portable ? null : _this8.atime,
      ctime: _this8.portable ? null : _this8.ctime
    });

    if (pathWarn) {
      _this8.warn('TAR_ENTRY_INFO', "stripping ".concat(pathWarn, " from absolute path"), {
        entry: _assertThisInitialized(_this8),
        path: pathWarn + _this8.path
      });
    }

    if (_this8.header.encode() && !_this8.noPax) {
      _get(_getPrototypeOf(WriteEntryTar.prototype), "write", _assertThisInitialized(_this8)).call(_assertThisInitialized(_this8), new Pax({
        atime: _this8.portable ? null : _this8.atime,
        ctime: _this8.portable ? null : _this8.ctime,
        gid: _this8.portable ? null : _this8.gid,
        mtime: _this8.noMtime ? null : _this8.mtime,
        path: _this8[PREFIX](_this8.path),
        linkpath: _this8.type === 'Link' ? _this8[PREFIX](_this8.linkpath) : _this8.linkpath,
        size: _this8.size,
        uid: _this8.portable ? null : _this8.uid,
        uname: _this8.portable ? null : _this8.uname,
        dev: _this8.portable ? null : _this8.readEntry.dev,
        ino: _this8.portable ? null : _this8.readEntry.ino,
        nlink: _this8.portable ? null : _this8.readEntry.nlink
      }).encode());
    }

    _get(_getPrototypeOf(WriteEntryTar.prototype), "write", _assertThisInitialized(_this8)).call(_assertThisInitialized(_this8), _this8.header.block);

    readEntry.pipe(_assertThisInitialized(_this8));
    return _this8;
  }

  _createClass(WriteEntryTar, [{
    key: PREFIX,
    value: function value(path) {
      return prefixPath(path, this.prefix);
    }
  }, {
    key: MODE,
    value: function value(mode) {
      return modeFix(mode, this.type === 'Directory', this.portable);
    }
  }, {
    key: "write",
    value: function write(data) {
      var writeLen = data.length;

      if (writeLen > this.blockRemain) {
        throw new Error('writing more to entry than is appropriate');
      }

      this.blockRemain -= writeLen;
      return _get(_getPrototypeOf(WriteEntryTar.prototype), "write", this).call(this, data);
    }
  }, {
    key: "end",
    value: function end() {
      if (this.blockRemain) {
        _get(_getPrototypeOf(WriteEntryTar.prototype), "write", this).call(this, Buffer.alloc(this.blockRemain));
      }

      return _get(_getPrototypeOf(WriteEntryTar.prototype), "end", this).call(this);
    }
  }]);

  return WriteEntryTar;
}(Minipass));
WriteEntry.Sync = WriteEntrySync;
WriteEntry.Tar = WriteEntryTar;

var getType = function getType(stat) {
  return stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';
};

module.exports = WriteEntry;