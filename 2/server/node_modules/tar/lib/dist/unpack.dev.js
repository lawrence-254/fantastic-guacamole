'use strict'; // the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.
// but the path reservations are required to avoid race conditions where
// parallelized unpack ops may mess with one another, due to dependencies
// (like a Link depending on its target) or destructive operations (like
// clobbering an fs object to create one of a different type.)

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var assert = require('assert');

var Parser = require('./parse.js');

var fs = require('fs');

var fsm = require('fs-minipass');

var path = require('path');

var mkdir = require('./mkdir.js');

var wc = require('./winchars.js');

var pathReservations = require('./path-reservations.js');

var stripAbsolutePath = require('./strip-absolute-path.js');

var normPath = require('./normalize-windows-path.js');

var stripSlash = require('./strip-trailing-slashes.js');

var normalize = require('./normalize-unicode.js');

var ONENTRY = Symbol('onEntry');
var CHECKFS = Symbol('checkFs');
var CHECKFS2 = Symbol('checkFs2');
var PRUNECACHE = Symbol('pruneCache');
var ISREUSABLE = Symbol('isReusable');
var MAKEFS = Symbol('makeFs');
var FILE = Symbol('file');
var DIRECTORY = Symbol('directory');
var LINK = Symbol('link');
var SYMLINK = Symbol('symlink');
var HARDLINK = Symbol('hardlink');
var UNSUPPORTED = Symbol('unsupported');
var CHECKPATH = Symbol('checkPath');
var MKDIR = Symbol('mkdir');
var ONERROR = Symbol('onError');
var PENDING = Symbol('pending');
var PEND = Symbol('pend');
var UNPEND = Symbol('unpend');
var ENDED = Symbol('ended');
var MAYBECLOSE = Symbol('maybeClose');
var SKIP = Symbol('skip');
var DOCHOWN = Symbol('doChown');
var UID = Symbol('uid');
var GID = Symbol('gid');
var CHECKED_CWD = Symbol('checkedCwd');

var crypto = require('crypto');

var getFlag = require('./get-write-flag.js');

var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var isWindows = platform === 'win32';
var DEFAULT_MAX_DEPTH = 1024; // Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183

/* istanbul ignore next */

var unlinkFile = function unlinkFile(path, cb) {
  if (!isWindows) {
    return fs.unlink(path, cb);
  }

  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');
  fs.rename(path, name, function (er) {
    if (er) {
      return cb(er);
    }

    fs.unlink(name, cb);
  });
};
/* istanbul ignore next */


var unlinkFileSync = function unlinkFileSync(path) {
  if (!isWindows) {
    return fs.unlinkSync(path);
  }

  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');
  fs.renameSync(path, name);
  fs.unlinkSync(name);
}; // this.gid, entry.gid, this.processUid


var uint32 = function uint32(a, b, c) {
  return a === a >>> 0 ? a : b === b >>> 0 ? b : c;
}; // clear the cache if it's a case-insensitive unicode-squashing match.
// we can't know if the current file system is case-sensitive or supports
// unicode fully, so we check for similarity on the maximally compatible
// representation.  Err on the side of pruning, since all it's doing is
// preventing lstats, and it's not the end of the world if we get a false
// positive.
// Note that on windows, we always drop the entire cache whenever a
// symbolic link is encountered, because 8.3 filenames are impossible
// to reason about, and collisions are hazards rather than just failures.


var cacheKeyNormalize = function cacheKeyNormalize(path) {
  return stripSlash(normPath(normalize(path))).toLowerCase();
};

var pruneCache = function pruneCache(cache, abs) {
  abs = cacheKeyNormalize(abs);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = cache.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _path = _step.value;
      var pnorm = cacheKeyNormalize(_path);

      if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {
        cache["delete"](_path);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

var dropCache = function dropCache(cache) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = cache.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var key = _step2.value;
      cache["delete"](key);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
};

var Unpack =
/*#__PURE__*/
function (_Parser) {
  _inherits(Unpack, _Parser);

  function Unpack(opt) {
    var _this;

    _classCallCheck(this, Unpack);

    if (!opt) {
      opt = {};
    }

    opt.ondone = function (_) {
      _this[ENDED] = true;

      _this[MAYBECLOSE]();
    };

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Unpack).call(this, opt));
    _this[CHECKED_CWD] = false;
    _this.reservations = pathReservations();
    _this.transform = typeof opt.transform === 'function' ? opt.transform : null;
    _this.writable = true;
    _this.readable = false;
    _this[PENDING] = 0;
    _this[ENDED] = false;
    _this.dirCache = opt.dirCache || new Map();

    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
      // need both or neither
      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {
        throw new TypeError('cannot set owner without number uid and gid');
      }

      if (opt.preserveOwner) {
        throw new TypeError('cannot preserve owner in archive and also set owner explicitly');
      }

      _this.uid = opt.uid;
      _this.gid = opt.gid;
      _this.setOwner = true;
    } else {
      _this.uid = null;
      _this.gid = null;
      _this.setOwner = false;
    } // default true for root


    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {
      _this.preserveOwner = process.getuid && process.getuid() === 0;
    } else {
      _this.preserveOwner = !!opt.preserveOwner;
    }

    _this.processUid = (_this.preserveOwner || _this.setOwner) && process.getuid ? process.getuid() : null;
    _this.processGid = (_this.preserveOwner || _this.setOwner) && process.getgid ? process.getgid() : null; // prevent excessively deep nesting of subfolders
    // set to `Infinity` to remove this restriction

    _this.maxDepth = typeof opt.maxDepth === 'number' ? opt.maxDepth : DEFAULT_MAX_DEPTH; // mostly just for testing, but useful in some cases.
    // Forcibly trigger a chown on every entry, no matter what

    _this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms

    _this.win32 = !!opt.win32 || isWindows; // do not unpack over files that are newer than what's in the archive

    _this.newer = !!opt.newer; // do not unpack over ANY files

    _this.keep = !!opt.keep; // do not set mtime/atime of extracted entries

    _this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks
    // without this, warn and skip .., relativize absolutes, and error
    // on symlinks in extraction path

    _this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard
    // links, and removes symlink directories rather than erroring

    _this.unlink = !!opt.unlink;
    _this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));
    _this.strip = +opt.strip || 0; // if we're not chmodding, then we don't need the process umask

    _this.processUmask = opt.noChmod ? 0 : process.umask();
    _this.umask = typeof opt.umask === 'number' ? opt.umask : _this.processUmask; // default mode for dirs created as parents

    _this.dmode = opt.dmode || 511 & ~_this.umask;
    _this.fmode = opt.fmode || 438 & ~_this.umask;

    _this.on('entry', function (entry) {
      return _this[ONENTRY](entry);
    });

    return _this;
  } // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.


  _createClass(Unpack, [{
    key: "warn",
    value: function warn(code, msg) {
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {
        data.recoverable = false;
      }

      return _get(_getPrototypeOf(Unpack.prototype), "warn", this).call(this, code, msg, data);
    }
  }, {
    key: MAYBECLOSE,
    value: function value() {
      if (this[ENDED] && this[PENDING] === 0) {
        this.emit('prefinish');
        this.emit('finish');
        this.emit('end');
      }
    }
  }, {
    key: CHECKPATH,
    value: function value(entry) {
      var p = normPath(entry.path);
      var parts = p.split('/');

      if (this.strip) {
        if (parts.length < this.strip) {
          return false;
        }

        if (entry.type === 'Link') {
          var linkparts = normPath(entry.linkpath).split('/');

          if (linkparts.length >= this.strip) {
            entry.linkpath = linkparts.slice(this.strip).join('/');
          } else {
            return false;
          }
        }

        parts.splice(0, this.strip);
        entry.path = parts.join('/');
      }

      if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
        this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {
          entry: entry,
          path: p,
          depth: parts.length,
          maxDepth: this.maxDepth
        });
        return false;
      }

      if (!this.preservePaths) {
        if (parts.includes('..') || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
          this.warn('TAR_ENTRY_ERROR', "path contains '..'", {
            entry: entry,
            path: p
          });
          return false;
        } // strip off the root


        var _stripAbsolutePath = stripAbsolutePath(p),
            _stripAbsolutePath2 = _slicedToArray(_stripAbsolutePath, 2),
            root = _stripAbsolutePath2[0],
            stripped = _stripAbsolutePath2[1];

        if (root) {
          entry.path = stripped;
          this.warn('TAR_ENTRY_INFO', "stripping ".concat(root, " from absolute path"), {
            entry: entry,
            path: p
          });
        }
      }

      if (path.isAbsolute(entry.path)) {
        entry.absolute = normPath(path.resolve(entry.path));
      } else {
        entry.absolute = normPath(path.resolve(this.cwd, entry.path));
      } // if we somehow ended up with a path that escapes the cwd, and we are
      // not in preservePaths mode, then something is fishy!  This should have
      // been prevented above, so ignore this for coverage.

      /* istanbul ignore if - defense in depth */


      if (!this.preservePaths && entry.absolute.indexOf(this.cwd + '/') !== 0 && entry.absolute !== this.cwd) {
        this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {
          entry: entry,
          path: normPath(entry.path),
          resolvedPath: entry.absolute,
          cwd: this.cwd
        });
        return false;
      } // an archive can set properties on the extraction directory, but it
      // may not replace the cwd with a different kind of thing entirely.


      if (entry.absolute === this.cwd && entry.type !== 'Directory' && entry.type !== 'GNUDumpDir') {
        return false;
      } // only encode : chars that aren't drive letter indicators


      if (this.win32) {
        var _path$win32$parse = path.win32.parse(entry.absolute),
            aRoot = _path$win32$parse.root;

        entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));

        var _path$win32$parse2 = path.win32.parse(entry.path),
            pRoot = _path$win32$parse2.root;

        entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
      }

      return true;
    }
  }, {
    key: ONENTRY,
    value: function value(entry) {
      if (!this[CHECKPATH](entry)) {
        return entry.resume();
      }

      assert.equal(_typeof(entry.absolute), 'string');

      switch (entry.type) {
        case 'Directory':
        case 'GNUDumpDir':
          if (entry.mode) {
            entry.mode = entry.mode | 448;
          }

        // eslint-disable-next-line no-fallthrough

        case 'File':
        case 'OldFile':
        case 'ContiguousFile':
        case 'Link':
        case 'SymbolicLink':
          return this[CHECKFS](entry);

        case 'CharacterDevice':
        case 'BlockDevice':
        case 'FIFO':
        default:
          return this[UNSUPPORTED](entry);
      }
    }
  }, {
    key: ONERROR,
    value: function value(er, entry) {
      // Cwd has to exist, or else nothing works. That's serious.
      // Other errors are warnings, which raise the error in strict
      // mode, but otherwise continue on.
      if (er.name === 'CwdError') {
        this.emit('error', er);
      } else {
        this.warn('TAR_ENTRY_ERROR', er, {
          entry: entry
        });
        this[UNPEND]();
        entry.resume();
      }
    }
  }, {
    key: MKDIR,
    value: function value(dir, mode, cb) {
      mkdir(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode,
        noChmod: this.noChmod
      }, cb);
    }
  }, {
    key: DOCHOWN,
    value: function value(entry) {
      // in preserve owner mode, chown if the entry doesn't match process
      // in set owner mode, chown if setting doesn't match process
      return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;
    }
  }, {
    key: UID,
    value: function value(entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
  }, {
    key: GID,
    value: function value(entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
  }, {
    key: FILE,
    value: function value(entry, fullyDone) {
      var _this2 = this;

      var mode = entry.mode & 4095 || this.fmode;
      var stream = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode: mode,
        autoClose: false
      });
      stream.on('error', function (er) {
        if (stream.fd) {
          fs.close(stream.fd, function () {});
        } // flush all the data out so that we aren't left hanging
        // if the error wasn't actually fatal.  otherwise the parse
        // is blocked, and we never proceed.


        stream.write = function () {
          return true;
        };

        _this2[ONERROR](er, entry);

        fullyDone();
      });
      var actions = 1;

      var done = function done(er) {
        if (er) {
          /* istanbul ignore else - we should always have a fd by now */
          if (stream.fd) {
            fs.close(stream.fd, function () {});
          }

          _this2[ONERROR](er, entry);

          fullyDone();
          return;
        }

        if (--actions === 0) {
          fs.close(stream.fd, function (er) {
            if (er) {
              _this2[ONERROR](er, entry);
            } else {
              _this2[UNPEND]();
            }

            fullyDone();
          });
        }
      };

      stream.on('finish', function (_) {
        // if futimes fails, try utimes
        // if utimes fails, fail with the original error
        // same for fchown/chown
        var abs = entry.absolute;
        var fd = stream.fd;

        if (entry.mtime && !_this2.noMtime) {
          actions++;
          var atime = entry.atime || new Date();
          var mtime = entry.mtime;
          fs.futimes(fd, atime, mtime, function (er) {
            return er ? fs.utimes(abs, atime, mtime, function (er2) {
              return done(er2 && er);
            }) : done();
          });
        }

        if (_this2[DOCHOWN](entry)) {
          actions++;

          var uid = _this2[UID](entry);

          var gid = _this2[GID](entry);

          fs.fchown(fd, uid, gid, function (er) {
            return er ? fs.chown(abs, uid, gid, function (er2) {
              return done(er2 && er);
            }) : done();
          });
        }

        done();
      });
      var tx = this.transform ? this.transform(entry) || entry : entry;

      if (tx !== entry) {
        tx.on('error', function (er) {
          _this2[ONERROR](er, entry);

          fullyDone();
        });
        entry.pipe(tx);
      }

      tx.pipe(stream);
    }
  }, {
    key: DIRECTORY,
    value: function value(entry, fullyDone) {
      var _this3 = this;

      var mode = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode, function (er) {
        if (er) {
          _this3[ONERROR](er, entry);

          fullyDone();
          return;
        }

        var actions = 1;

        var done = function done(_) {
          if (--actions === 0) {
            fullyDone();

            _this3[UNPEND]();

            entry.resume();
          }
        };

        if (entry.mtime && !_this3.noMtime) {
          actions++;
          fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
        }

        if (_this3[DOCHOWN](entry)) {
          actions++;
          fs.chown(entry.absolute, _this3[UID](entry), _this3[GID](entry), done);
        }

        done();
      });
    }
  }, {
    key: UNSUPPORTED,
    value: function value(entry) {
      entry.unsupported = true;
      this.warn('TAR_ENTRY_UNSUPPORTED', "unsupported entry type: ".concat(entry.type), {
        entry: entry
      });
      entry.resume();
    }
  }, {
    key: SYMLINK,
    value: function value(entry, done) {
      this[LINK](entry, entry.linkpath, 'symlink', done);
    }
  }, {
    key: HARDLINK,
    value: function value(entry, done) {
      var linkpath = normPath(path.resolve(this.cwd, entry.linkpath));
      this[LINK](entry, linkpath, 'link', done);
    }
  }, {
    key: PEND,
    value: function value() {
      this[PENDING]++;
    }
  }, {
    key: UNPEND,
    value: function value() {
      this[PENDING]--;
      this[MAYBECLOSE]();
    }
  }, {
    key: SKIP,
    value: function value(entry) {
      this[UNPEND]();
      entry.resume();
    } // Check if we can reuse an existing filesystem entry safely and
    // overwrite it, rather than unlinking and recreating
    // Windows doesn't report a useful nlink, so we just never reuse entries

  }, {
    key: ISREUSABLE,
    value: function value(entry, st) {
      return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
    } // check if a thing is there, and if so, try to clobber it

  }, {
    key: CHECKFS,
    value: function value(entry) {
      var _this4 = this;

      this[PEND]();
      var paths = [entry.path];

      if (entry.linkpath) {
        paths.push(entry.linkpath);
      }

      this.reservations.reserve(paths, function (done) {
        return _this4[CHECKFS2](entry, done);
      });
    }
  }, {
    key: PRUNECACHE,
    value: function value(entry) {
      // if we are not creating a directory, and the path is in the dirCache,
      // then that means we are about to delete the directory we created
      // previously, and it is no longer going to be a directory, and neither
      // is any of its children.
      // If a symbolic link is encountered, all bets are off.  There is no
      // reasonable way to sanitize the cache in such a way we will be able to
      // avoid having filesystem collisions.  If this happens with a non-symlink
      // entry, it'll just fail to unpack, but a symlink to a directory, using an
      // 8.3 shortname or certain unicode attacks, can evade detection and lead
      // to arbitrary writes to anywhere on the system.
      if (entry.type === 'SymbolicLink') {
        dropCache(this.dirCache);
      } else if (entry.type !== 'Directory') {
        pruneCache(this.dirCache, entry.absolute);
      }
    }
  }, {
    key: CHECKFS2,
    value: function value(entry, fullyDone) {
      var _this5 = this;

      this[PRUNECACHE](entry);

      var done = function done(er) {
        _this5[PRUNECACHE](entry);

        fullyDone(er);
      };

      var checkCwd = function checkCwd() {
        _this5[MKDIR](_this5.cwd, _this5.dmode, function (er) {
          if (er) {
            _this5[ONERROR](er, entry);

            done();
            return;
          }

          _this5[CHECKED_CWD] = true;
          start();
        });
      };

      var start = function start() {
        if (entry.absolute !== _this5.cwd) {
          var parent = normPath(path.dirname(entry.absolute));

          if (parent !== _this5.cwd) {
            return _this5[MKDIR](parent, _this5.dmode, function (er) {
              if (er) {
                _this5[ONERROR](er, entry);

                done();
                return;
              }

              afterMakeParent();
            });
          }
        }

        afterMakeParent();
      };

      var afterMakeParent = function afterMakeParent() {
        fs.lstat(entry.absolute, function (lstatEr, st) {
          if (st && (_this5.keep || _this5.newer && st.mtime > entry.mtime)) {
            _this5[SKIP](entry);

            done();
            return;
          }

          if (lstatEr || _this5[ISREUSABLE](entry, st)) {
            return _this5[MAKEFS](null, entry, done);
          }

          if (st.isDirectory()) {
            if (entry.type === 'Directory') {
              var needChmod = !_this5.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;

              var afterChmod = function afterChmod(er) {
                return _this5[MAKEFS](er, entry, done);
              };

              if (!needChmod) {
                return afterChmod();
              }

              return fs.chmod(entry.absolute, entry.mode, afterChmod);
            } // Not a dir entry, have to remove it.
            // NB: the only way to end up with an entry that is the cwd
            // itself, in such a way that == does not detect, is a
            // tricky windows absolute path with UNC or 8.3 parts (and
            // preservePaths:true, or else it will have been stripped).
            // In that case, the user has opted out of path protections
            // explicitly, so if they blow away the cwd, c'est la vie.


            if (entry.absolute !== _this5.cwd) {
              return fs.rmdir(entry.absolute, function (er) {
                return _this5[MAKEFS](er, entry, done);
              });
            }
          } // not a dir, and not reusable
          // don't remove if the cwd, we want that error


          if (entry.absolute === _this5.cwd) {
            return _this5[MAKEFS](null, entry, done);
          }

          unlinkFile(entry.absolute, function (er) {
            return _this5[MAKEFS](er, entry, done);
          });
        });
      };

      if (this[CHECKED_CWD]) {
        start();
      } else {
        checkCwd();
      }
    }
  }, {
    key: MAKEFS,
    value: function value(er, entry, done) {
      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }

      switch (entry.type) {
        case 'File':
        case 'OldFile':
        case 'ContiguousFile':
          return this[FILE](entry, done);

        case 'Link':
          return this[HARDLINK](entry, done);

        case 'SymbolicLink':
          return this[SYMLINK](entry, done);

        case 'Directory':
        case 'GNUDumpDir':
          return this[DIRECTORY](entry, done);
      }
    }
  }, {
    key: LINK,
    value: function value(entry, linkpath, link, done) {
      var _this6 = this;

      // XXX: get the type ('symlink' or 'junction') for windows
      fs[link](linkpath, entry.absolute, function (er) {
        if (er) {
          _this6[ONERROR](er, entry);
        } else {
          _this6[UNPEND]();

          entry.resume();
        }

        done();
      });
    }
  }]);

  return Unpack;
}(Parser);

var callSync = function callSync(fn) {
  try {
    return [null, fn()];
  } catch (er) {
    return [er, null];
  }
};

var UnpackSync =
/*#__PURE__*/
function (_Unpack) {
  _inherits(UnpackSync, _Unpack);

  function UnpackSync() {
    _classCallCheck(this, UnpackSync);

    return _possibleConstructorReturn(this, _getPrototypeOf(UnpackSync).apply(this, arguments));
  }

  _createClass(UnpackSync, [{
    key: MAKEFS,
    value: function value(er, entry) {
      return _get(_getPrototypeOf(UnpackSync.prototype), MAKEFS, this).call(this, er, entry, function () {});
    }
  }, {
    key: CHECKFS,
    value: function value(entry) {
      this[PRUNECACHE](entry);

      if (!this[CHECKED_CWD]) {
        var _er = this[MKDIR](this.cwd, this.dmode);

        if (_er) {
          return this[ONERROR](_er, entry);
        }

        this[CHECKED_CWD] = true;
      } // don't bother to make the parent if the current entry is the cwd,
      // we've already checked it.


      if (entry.absolute !== this.cwd) {
        var parent = normPath(path.dirname(entry.absolute));

        if (parent !== this.cwd) {
          var mkParent = this[MKDIR](parent, this.dmode);

          if (mkParent) {
            return this[ONERROR](mkParent, entry);
          }
        }
      }

      var _callSync = callSync(function () {
        return fs.lstatSync(entry.absolute);
      }),
          _callSync2 = _slicedToArray(_callSync, 2),
          lstatEr = _callSync2[0],
          st = _callSync2[1];

      if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
        return this[SKIP](entry);
      }

      if (lstatEr || this[ISREUSABLE](entry, st)) {
        return this[MAKEFS](null, entry);
      }

      if (st.isDirectory()) {
        if (entry.type === 'Directory') {
          var needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;

          var _ref = needChmod ? callSync(function () {
            fs.chmodSync(entry.absolute, entry.mode);
          }) : [],
              _ref2 = _slicedToArray(_ref, 1),
              _er3 = _ref2[0];

          return this[MAKEFS](_er3, entry);
        } // not a dir entry, have to remove it


        var _callSync3 = callSync(function () {
          return fs.rmdirSync(entry.absolute);
        }),
            _callSync4 = _slicedToArray(_callSync3, 1),
            _er2 = _callSync4[0];

        this[MAKEFS](_er2, entry);
      } // not a dir, and not reusable.
      // don't remove if it's the cwd, since we want that error.


      var _ref3 = entry.absolute === this.cwd ? [] : callSync(function () {
        return unlinkFileSync(entry.absolute);
      }),
          _ref4 = _slicedToArray(_ref3, 1),
          er = _ref4[0];

      this[MAKEFS](er, entry);
    }
  }, {
    key: FILE,
    value: function value(entry, done) {
      var _this7 = this;

      var mode = entry.mode & 4095 || this.fmode;

      var oner = function oner(er) {
        var closeError;

        try {
          fs.closeSync(fd);
        } catch (e) {
          closeError = e;
        }

        if (er || closeError) {
          _this7[ONERROR](er || closeError, entry);
        }

        done();
      };

      var fd;

      try {
        fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);
      } catch (er) {
        return oner(er);
      }

      var tx = this.transform ? this.transform(entry) || entry : entry;

      if (tx !== entry) {
        tx.on('error', function (er) {
          return _this7[ONERROR](er, entry);
        });
        entry.pipe(tx);
      }

      tx.on('data', function (chunk) {
        try {
          fs.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      });
      tx.on('end', function (_) {
        var er = null; // try both, falling futimes back to utimes
        // if either fails, handle the first error

        if (entry.mtime && !_this7.noMtime) {
          var atime = entry.atime || new Date();
          var mtime = entry.mtime;

          try {
            fs.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs.utimesSync(entry.absolute, atime, mtime);
            } catch (utimeser) {
              er = futimeser;
            }
          }
        }

        if (_this7[DOCHOWN](entry)) {
          var uid = _this7[UID](entry);

          var gid = _this7[GID](entry);

          try {
            fs.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs.chownSync(entry.absolute, uid, gid);
            } catch (chowner) {
              er = er || fchowner;
            }
          }
        }

        oner(er);
      });
    }
  }, {
    key: DIRECTORY,
    value: function value(entry, done) {
      var mode = entry.mode & 4095 || this.dmode;
      var er = this[MKDIR](entry.absolute, mode);

      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }

      if (entry.mtime && !this.noMtime) {
        try {
          fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
        } catch (er) {}
      }

      if (this[DOCHOWN](entry)) {
        try {
          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch (er) {}
      }

      done();
      entry.resume();
    }
  }, {
    key: MKDIR,
    value: function value(dir, mode) {
      try {
        return mkdir.sync(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode: mode
        });
      } catch (er) {
        return er;
      }
    }
  }, {
    key: LINK,
    value: function value(entry, linkpath, link, done) {
      try {
        fs[link + 'Sync'](linkpath, entry.absolute);
        done();
        entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  }]);

  return UnpackSync;
}(Unpack);

Unpack.Sync = UnpackSync;
module.exports = Unpack;