'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var proc = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process ? process : {
  stdout: null,
  stderr: null
};

var EE = require('events');

var Stream = require('stream');

var stringdecoder = require('string_decoder');

var SD = stringdecoder.StringDecoder;
var EOF = Symbol('EOF');
var MAYBE_EMIT_END = Symbol('maybeEmitEnd');
var EMITTED_END = Symbol('emittedEnd');
var EMITTING_END = Symbol('emittingEnd');
var EMITTED_ERROR = Symbol('emittedError');
var CLOSED = Symbol('closed');
var READ = Symbol('read');
var FLUSH = Symbol('flush');
var FLUSHCHUNK = Symbol('flushChunk');
var ENCODING = Symbol('encoding');
var DECODER = Symbol('decoder');
var FLOWING = Symbol('flowing');
var PAUSED = Symbol('paused');
var RESUME = Symbol('resume');
var BUFFER = Symbol('buffer');
var PIPES = Symbol('pipes');
var BUFFERLENGTH = Symbol('bufferLength');
var BUFFERPUSH = Symbol('bufferPush');
var BUFFERSHIFT = Symbol('bufferShift');
var OBJECTMODE = Symbol('objectMode'); // internal event when stream is destroyed

var DESTROYED = Symbol('destroyed'); // internal event when stream has an error

var ERROR = Symbol('error');
var EMITDATA = Symbol('emitData');
var EMITEND = Symbol('emitEnd');
var EMITEND2 = Symbol('emitEnd2');
var ASYNC = Symbol('async');
var ABORT = Symbol('abort');
var ABORTED = Symbol('aborted');
var SIGNAL = Symbol('signal');

var defer = function defer(fn) {
  return Promise.resolve().then(fn);
}; // TODO remove when Node v8 support drops


var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';
var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');
var ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.

var isEndish = function isEndish(ev) {
  return ev === 'end' || ev === 'finish' || ev === 'prefinish';
};

var isArrayBuffer = function isArrayBuffer(b) {
  return b instanceof ArrayBuffer || _typeof(b) === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;
};

var isArrayBufferView = function isArrayBufferView(b) {
  return !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
};

var Pipe =
/*#__PURE__*/
function () {
  function Pipe(src, dest, opts) {
    _classCallCheck(this, Pipe);

    this.src = src;
    this.dest = dest;
    this.opts = opts;

    this.ondrain = function () {
      return src[RESUME]();
    };

    dest.on('drain', this.ondrain);
  }

  _createClass(Pipe, [{
    key: "unpipe",
    value: function unpipe() {
      this.dest.removeListener('drain', this.ondrain);
    } // istanbul ignore next - only here for the prototype

  }, {
    key: "proxyErrors",
    value: function proxyErrors() {}
  }, {
    key: "end",
    value: function end() {
      this.unpipe();
      if (this.opts.end) this.dest.end();
    }
  }]);

  return Pipe;
}();

var PipeProxyErrors =
/*#__PURE__*/
function (_Pipe) {
  _inherits(PipeProxyErrors, _Pipe);

  _createClass(PipeProxyErrors, [{
    key: "unpipe",
    value: function unpipe() {
      this.src.removeListener('error', this.proxyErrors);

      _get(_getPrototypeOf(PipeProxyErrors.prototype), "unpipe", this).call(this);
    }
  }]);

  function PipeProxyErrors(src, dest, opts) {
    var _this;

    _classCallCheck(this, PipeProxyErrors);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PipeProxyErrors).call(this, src, dest, opts));

    _this.proxyErrors = function (er) {
      return dest.emit('error', er);
    };

    src.on('error', _this.proxyErrors);
    return _this;
  }

  return PipeProxyErrors;
}(Pipe);

var Minipass =
/*#__PURE__*/
function (_Stream) {
  _inherits(Minipass, _Stream);

  function Minipass(options) {
    var _this2;

    _classCallCheck(this, Minipass);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Minipass).call(this));
    _this2[FLOWING] = false; // whether we're explicitly paused

    _this2[PAUSED] = false;
    _this2[PIPES] = [];
    _this2[BUFFER] = [];
    _this2[OBJECTMODE] = options && options.objectMode || false;
    if (_this2[OBJECTMODE]) _this2[ENCODING] = null;else _this2[ENCODING] = options && options.encoding || null;
    if (_this2[ENCODING] === 'buffer') _this2[ENCODING] = null;
    _this2[ASYNC] = options && !!options.async || false;
    _this2[DECODER] = _this2[ENCODING] ? new SD(_this2[ENCODING]) : null;
    _this2[EOF] = false;
    _this2[EMITTED_END] = false;
    _this2[EMITTING_END] = false;
    _this2[CLOSED] = false;
    _this2[EMITTED_ERROR] = null;
    _this2.writable = true;
    _this2.readable = true;
    _this2[BUFFERLENGTH] = 0;
    _this2[DESTROYED] = false;

    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(_assertThisInitialized(_this2), 'buffer', {
        get: function get() {
          return _this2[BUFFER];
        }
      });
    }

    if (options && options.debugExposePipes === true) {
      Object.defineProperty(_assertThisInitialized(_this2), 'pipes', {
        get: function get() {
          return _this2[PIPES];
        }
      });
    }

    _this2[SIGNAL] = options && options.signal;
    _this2[ABORTED] = false;

    if (_this2[SIGNAL]) {
      _this2[SIGNAL].addEventListener('abort', function () {
        return _this2[ABORT]();
      });

      if (_this2[SIGNAL].aborted) {
        _this2[ABORT]();
      }
    }

    return _this2;
  }

  _createClass(Minipass, [{
    key: "setEncoding",
    value: function setEncoding(enc) {
      this.encoding = enc;
    }
  }, {
    key: ABORT,
    // drop everything and get out of the flow completely
    value: function value() {
      this[ABORTED] = true;
      this.emit('abort', this[SIGNAL].reason);
      this.destroy(this[SIGNAL].reason);
    }
  }, {
    key: "write",
    value: function write(chunk, encoding, cb) {
      if (this[ABORTED]) return false;
      if (this[EOF]) throw new Error('write after end');

      if (this[DESTROYED]) {
        this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {
          code: 'ERR_STREAM_DESTROYED'
        }));
        return true;
      }

      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
      if (!encoding) encoding = 'utf8';
      var fn = this[ASYNC] ? defer : function (f) {
        return f();
      }; // convert array buffers and typed array views into buffers
      // at some point in the future, we may want to do the opposite!
      // leave strings and buffers as-is
      // anything else switches us into object mode

      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set
          this.objectMode = true;
      } // handle object mode up front, since it's simpler
      // this yields better performance, fewer checks later.


      if (this[OBJECTMODE]) {
        /* istanbul ignore if - maybe impossible? */
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit('readable');
        if (cb) fn(cb);
        return this.flowing;
      } // at this point the chunk is a buffer or string
      // don't buffer it up or send it to the decoder


      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0) this.emit('readable');
        if (cb) fn(cb);
        return this.flowing;
      } // fast-path writing strings of same encoding to a stream with
      // an empty buffer, skipping the buffer/decoder dance


      if (typeof chunk === 'string' && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }

      if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk); // Note: flushing CAN potentially switch us into not-flowing mode

      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0) this.emit('readable');
      if (cb) fn(cb);
      return this.flowing;
    }
  }, {
    key: "read",
    value: function read(n) {
      if (this[DESTROYED]) return null;

      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }

      if (this[OBJECTMODE]) n = null;

      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        if (this.encoding) this[BUFFER] = [this[BUFFER].join('')];else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
      }

      var ret = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
  }, {
    key: READ,
    value: function value(n, chunk) {
      if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {
        this[BUFFER][0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit('data', chunk);
      if (!this[BUFFER].length && !this[EOF]) this.emit('drain');
      return chunk;
    }
  }, {
    key: "end",
    value: function end(chunk, encoding, cb) {
      if (typeof chunk === 'function') cb = chunk, chunk = null;
      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
      if (chunk) this.write(chunk, encoding);
      if (cb) this.once('end', cb);
      this[EOF] = true;
      this.writable = false; // if we haven't written anything, then go ahead and emit,
      // even if we're not reading.
      // we'll re-emit if a new 'end' listener is added anyway.
      // This makes MP more suitable to write-only use cases.

      if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
      return this;
    } // don't let the internal resume be overwritten

  }, {
    key: RESUME,
    value: function value() {
      if (this[DESTROYED]) return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit('resume');
      if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');
    }
  }, {
    key: "resume",
    value: function resume() {
      return this[RESUME]();
    }
  }, {
    key: "pause",
    value: function pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
  }, {
    key: BUFFERPUSH,
    value: function value(chunk) {
      if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
  }, {
    key: BUFFERSHIFT,
    value: function value() {
      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
  }, {
    key: FLUSH,
    value: function value(noDrain) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);

      if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');
    }
  }, {
    key: FLUSHCHUNK,
    value: function value(chunk) {
      this.emit('data', chunk);
      return this.flowing;
    }
  }, {
    key: "pipe",
    value: function pipe(dest, opts) {
      var _this3 = this;

      if (this[DESTROYED]) return;
      var ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors; // piping an ended stream ends immediately

      if (ended) {
        if (opts.end) dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC]) defer(function () {
          return _this3[RESUME]();
        });else this[RESUME]();
      }

      return dest;
    }
  }, {
    key: "unpipe",
    value: function unpipe(dest) {
      var p = this[PIPES].find(function (p) {
        return p.dest === dest;
      });

      if (p) {
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
  }, {
    key: "addListener",
    value: function addListener(ev, fn) {
      return this.on(ev, fn);
    }
  }, {
    key: "on",
    value: function on(ev, fn) {
      var _this4 = this;

      var ret = _get(_getPrototypeOf(Minipass.prototype), "on", this).call(this, ev, fn);

      if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'readable');else if (isEndish(ev) && this[EMITTED_END]) {
        _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, ev);

        this.removeAllListeners(ev);
      } else if (ev === 'error' && this[EMITTED_ERROR]) {
        if (this[ASYNC]) defer(function () {
          return fn.call(_this4, _this4[EMITTED_ERROR]);
        });else fn.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
  }, {
    key: MAYBE_EMIT_END,
    value: function value() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit('end');
        this.emit('prefinish');
        this.emit('finish');
        if (this[CLOSED]) this.emit('close');
        this[EMITTING_END] = false;
      }
    }
  }, {
    key: "emit",
    value: function emit(ev, data) {
      var _this5 = this,
          _get2;

      // error and close are only events allowed after calling destroy()
      if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(function () {
          return _this5[EMITDATA](data);
        }) : this[EMITDATA](data);
      } else if (ev === 'end') {
        return this[EMITEND]();
      } else if (ev === 'close') {
        this[CLOSED] = true; // don't emit close before 'end' and 'finish'

        if (!this[EMITTED_END] && !this[DESTROYED]) return;

        var _ret = _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'close');

        this.removeAllListeners('close');
        return _ret;
      } else if (ev === 'error') {
        this[EMITTED_ERROR] = data;

        _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, ERROR, data);

        var _ret2 = !this[SIGNAL] || this.listeners('error').length ? _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'error', data) : false;

        this[MAYBE_EMIT_END]();
        return _ret2;
      } else if (ev === 'resume') {
        var _ret3 = _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'resume');

        this[MAYBE_EMIT_END]();
        return _ret3;
      } else if (ev === 'finish' || ev === 'prefinish') {
        var _ret4 = _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, ev);

        this.removeAllListeners(ev);
        return _ret4;
      } // Some other unknown event

      for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        extra[_key - 2] = arguments[_key];
      }

      var ret = (_get2 = _get(_getPrototypeOf(Minipass.prototype), "emit", this)).call.apply(_get2, [this, ev, data].concat(extra));

      this[MAYBE_EMIT_END]();
      return ret;
    }
  }, {
    key: EMITDATA,
    value: function value(data) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this[PIPES][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;
          if (p.dest.write(data) === false) this.pause();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var ret = _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'data', data);

      this[MAYBE_EMIT_END]();
      return ret;
    }
  }, {
    key: EMITEND,
    value: function value() {
      var _this6 = this;

      if (this[EMITTED_END]) return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC]) defer(function () {
        return _this6[EMITEND2]();
      });else this[EMITEND2]();
    }
  }, {
    key: EMITEND2,
    value: function value() {
      if (this[DECODER]) {
        var data = this[DECODER].end();

        if (data) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this[PIPES][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var p = _step2.value;
              p.dest.write(data);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'data', data);
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this[PIPES][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _p = _step3.value;

          _p.end();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var ret = _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'end');

      this.removeAllListeners('end');
      return ret;
    } // const all = await stream.collect()

  }, {
    key: "collect",
    value: function collect() {
      var _this7 = this;

      var buf = [];
      if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised
      // by triggering the flow here.

      var p = this.promise();
      this.on('data', function (c) {
        buf.push(c);
        if (!_this7[OBJECTMODE]) buf.dataLength += c.length;
      });
      return p.then(function () {
        return buf;
      });
    } // const data = await stream.concat()

  }, {
    key: "concat",
    value: function concat() {
      var _this8 = this;

      return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(function (buf) {
        return _this8[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : _this8[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength);
      });
    } // stream.promise().then(() => done, er => emitted error)

  }, {
    key: "promise",
    value: function promise() {
      var _this9 = this;

      return new Promise(function (resolve, reject) {
        _this9.on(DESTROYED, function () {
          return reject(new Error('stream destroyed'));
        });

        _this9.on('error', function (er) {
          return reject(er);
        });

        _this9.on('end', function () {
          return resolve();
        });
      });
    } // for await (let chunk of stream)

  }, {
    key: ASYNCITERATOR,
    value: function value() {
      var _this10 = this;

      var stopped = false;

      var stop = function stop() {
        _this10.pause();

        stopped = true;
        return Promise.resolve({
          done: true
        });
      };

      var next = function next() {
        if (stopped) return stop();

        var res = _this10.read();

        if (res !== null) return Promise.resolve({
          done: false,
          value: res
        });
        if (_this10[EOF]) return stop();
        var resolve = null;
        var reject = null;

        var onerr = function onerr(er) {
          _this10.removeListener('data', ondata);

          _this10.removeListener('end', onend);

          _this10.removeListener(DESTROYED, ondestroy);

          stop();
          reject(er);
        };

        var ondata = function ondata(value) {
          _this10.removeListener('error', onerr);

          _this10.removeListener('end', onend);

          _this10.removeListener(DESTROYED, ondestroy);

          _this10.pause();

          resolve({
            value: value,
            done: !!_this10[EOF]
          });
        };

        var onend = function onend() {
          _this10.removeListener('error', onerr);

          _this10.removeListener('data', ondata);

          _this10.removeListener(DESTROYED, ondestroy);

          stop();
          resolve({
            done: true
          });
        };

        var ondestroy = function ondestroy() {
          return onerr(new Error('stream destroyed'));
        };

        return new Promise(function (res, rej) {
          reject = rej;
          resolve = res;

          _this10.once(DESTROYED, ondestroy);

          _this10.once('error', onerr);

          _this10.once('end', onend);

          _this10.once('data', ondata);
        });
      };

      return _defineProperty({
        next: next,
        "throw": stop,
        "return": stop
      }, ASYNCITERATOR, function () {
        return this;
      });
    } // for (let chunk of stream)

  }, {
    key: ITERATOR,
    value: function value() {
      var _this11 = this;

      var stopped = false;

      var stop = function stop() {
        _this11.pause();

        _this11.removeListener(ERROR, stop);

        _this11.removeListener(DESTROYED, stop);

        _this11.removeListener('end', stop);

        stopped = true;
        return {
          done: true
        };
      };

      var next = function next() {
        if (stopped) return stop();

        var value = _this11.read();

        return value === null ? stop() : {
          value: value
        };
      };

      this.once('end', stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return _defineProperty({
        next: next,
        "throw": stop,
        "return": stop
      }, ITERATOR, function () {
        return this;
      });
    }
  }, {
    key: "destroy",
    value: function destroy(er) {
      if (this[DESTROYED]) {
        if (er) this.emit('error', er);else this.emit(DESTROYED);
        return this;
      }

      this[DESTROYED] = true; // throw away all buffered data, it's never coming out

      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === 'function' && !this[CLOSED]) this.close();
      if (er) this.emit('error', er); // if no error to emit, still reject pending promises
      else this.emit(DESTROYED);
      return this;
    }
  }, {
    key: "bufferLength",
    get: function get() {
      return this[BUFFERLENGTH];
    }
  }, {
    key: "encoding",
    get: function get() {
      return this[ENCODING];
    },
    set: function set(enc) {
      var _this12 = this;

      if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');

      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map(function (chunk) {
          return _this12[DECODER].write(chunk);
        });
      }

      this[ENCODING] = enc;
    }
  }, {
    key: "objectMode",
    get: function get() {
      return this[OBJECTMODE];
    },
    set: function set(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
  }, {
    key: 'async',
    get: function get() {
      return this[ASYNC];
    },
    set: function set(a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
  }, {
    key: "aborted",
    get: function get() {
      return this[ABORTED];
    },
    set: function set(_) {}
  }, {
    key: "destroyed",
    get: function get() {
      return this[DESTROYED];
    }
  }, {
    key: "flowing",
    get: function get() {
      return this[FLOWING];
    }
  }, {
    key: "paused",
    get: function get() {
      return this[PAUSED];
    }
  }, {
    key: "emittedEnd",
    get: function get() {
      return this[EMITTED_END];
    }
  }], [{
    key: "isStream",
    value: function isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && ( // readable
      typeof s.pipe === 'function' || // writable
      typeof s.write === 'function' && typeof s.end === 'function'));
    }
  }]);

  return Minipass;
}(Stream);

exports.Minipass = Minipass;