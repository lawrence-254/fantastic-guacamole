// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var childProcess = require('child_process');

var _require = require('./process'),
    isLinux = _require.isLinux,
    getReport = _require.getReport;

var _require2 = require('./filesystem'),
    LDD_PATH = _require2.LDD_PATH,
    readFile = _require2.readFile,
    readFileSync = _require2.readFileSync;

var cachedFamilyFilesystem;
var cachedVersionFilesystem;
var command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';
var commandOut = '';

var safeCommand = function safeCommand() {
  if (!commandOut) {
    return new Promise(function (resolve) {
      childProcess.exec(command, function (err, out) {
        commandOut = err ? ' ' : out;
        resolve(commandOut);
      });
    });
  }

  return commandOut;
};

var safeCommandSync = function safeCommandSync() {
  if (!commandOut) {
    try {
      commandOut = childProcess.execSync(command, {
        encoding: 'utf8'
      });
    } catch (_err) {
      commandOut = ' ';
    }
  }

  return commandOut;
};
/**
 * A String constant containing the value `glibc`.
 * @type {string}
 * @public
 */


var GLIBC = 'glibc';
/**
 * A Regexp constant to get the GLIBC Version.
 * @type {string}
 */

var RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
/**
 * A String constant containing the value `musl`.
 * @type {string}
 * @public
 */

var MUSL = 'musl';

var isFileMusl = function isFileMusl(f) {
  return f.includes('libc.musl-') || f.includes('ld-musl-');
};

var familyFromReport = function familyFromReport() {
  var report = getReport();

  if (report.header && report.header.glibcVersionRuntime) {
    return GLIBC;
  }

  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return MUSL;
    }
  }

  return null;
};

var familyFromCommand = function familyFromCommand(out) {
  var _out$split = out.split(/[\r\n]+/),
      _out$split2 = _slicedToArray(_out$split, 2),
      getconf = _out$split2[0],
      ldd1 = _out$split2[1];

  if (getconf && getconf.includes(GLIBC)) {
    return GLIBC;
  }

  if (ldd1 && ldd1.includes(MUSL)) {
    return MUSL;
  }

  return null;
};

var getFamilyFromLddContent = function getFamilyFromLddContent(content) {
  if (content.includes('musl')) {
    return MUSL;
  }

  if (content.includes('GNU C Library')) {
    return GLIBC;
  }

  return null;
};

var familyFromFilesystem = function familyFromFilesystem() {
  var lddContent;
  return regeneratorRuntime.async(function familyFromFilesystem$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(cachedFamilyFilesystem !== undefined)) {
            _context.next = 2;
            break;
          }

          return _context.abrupt("return", cachedFamilyFilesystem);

        case 2:
          cachedFamilyFilesystem = null;
          _context.prev = 3;
          _context.next = 6;
          return regeneratorRuntime.awrap(readFile(LDD_PATH));

        case 6:
          lddContent = _context.sent;
          cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
          _context.next = 12;
          break;

        case 10:
          _context.prev = 10;
          _context.t0 = _context["catch"](3);

        case 12:
          return _context.abrupt("return", cachedFamilyFilesystem);

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[3, 10]]);
};

var familyFromFilesystemSync = function familyFromFilesystemSync() {
  if (cachedFamilyFilesystem !== undefined) {
    return cachedFamilyFilesystem;
  }

  cachedFamilyFilesystem = null;

  try {
    var lddContent = readFileSync(LDD_PATH);
    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
  } catch (e) {}

  return cachedFamilyFilesystem;
};
/**
 * Resolves with the libc family when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */


var family = function family() {
  var family, out;
  return regeneratorRuntime.async(function family$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          family = null;

          if (!isLinux()) {
            _context2.next = 11;
            break;
          }

          _context2.next = 4;
          return regeneratorRuntime.awrap(familyFromFilesystem());

        case 4:
          family = _context2.sent;

          if (!family) {
            family = familyFromReport();
          }

          if (family) {
            _context2.next = 11;
            break;
          }

          _context2.next = 9;
          return regeneratorRuntime.awrap(safeCommand());

        case 9:
          out = _context2.sent;
          family = familyFromCommand(out);

        case 11:
          return _context2.abrupt("return", family);

        case 12:
        case "end":
          return _context2.stop();
      }
    }
  });
};
/**
 * Returns the libc family when it can be determined, `null` otherwise.
 * @returns {?string}
 */


var familySync = function familySync() {
  var family = null;

  if (isLinux()) {
    family = familyFromFilesystemSync();

    if (!family) {
      family = familyFromReport();
    }

    if (!family) {
      var out = safeCommandSync();
      family = familyFromCommand(out);
    }
  }

  return family;
};
/**
 * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {Promise<boolean>}
 */


var isNonGlibcLinux = function isNonGlibcLinux() {
  return regeneratorRuntime.async(function isNonGlibcLinux$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.t0 = isLinux();

          if (!_context3.t0) {
            _context3.next = 7;
            break;
          }

          _context3.next = 4;
          return regeneratorRuntime.awrap(family());

        case 4:
          _context3.t1 = _context3.sent;
          _context3.t2 = GLIBC;
          _context3.t0 = _context3.t1 !== _context3.t2;

        case 7:
          return _context3.abrupt("return", _context3.t0);

        case 8:
        case "end":
          return _context3.stop();
      }
    }
  });
};
/**
 * Returns `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {boolean}
 */


var isNonGlibcLinuxSync = function isNonGlibcLinuxSync() {
  return isLinux() && familySync() !== GLIBC;
};

var versionFromFilesystem = function versionFromFilesystem() {
  var lddContent, versionMatch;
  return regeneratorRuntime.async(function versionFromFilesystem$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!(cachedVersionFilesystem !== undefined)) {
            _context4.next = 2;
            break;
          }

          return _context4.abrupt("return", cachedVersionFilesystem);

        case 2:
          cachedVersionFilesystem = null;
          _context4.prev = 3;
          _context4.next = 6;
          return regeneratorRuntime.awrap(readFile(LDD_PATH));

        case 6:
          lddContent = _context4.sent;
          versionMatch = lddContent.match(RE_GLIBC_VERSION);

          if (versionMatch) {
            cachedVersionFilesystem = versionMatch[1];
          }

          _context4.next = 13;
          break;

        case 11:
          _context4.prev = 11;
          _context4.t0 = _context4["catch"](3);

        case 13:
          return _context4.abrupt("return", cachedVersionFilesystem);

        case 14:
        case "end":
          return _context4.stop();
      }
    }
  }, null, null, [[3, 11]]);
};

var versionFromFilesystemSync = function versionFromFilesystemSync() {
  if (cachedVersionFilesystem !== undefined) {
    return cachedVersionFilesystem;
  }

  cachedVersionFilesystem = null;

  try {
    var lddContent = readFileSync(LDD_PATH);
    var versionMatch = lddContent.match(RE_GLIBC_VERSION);

    if (versionMatch) {
      cachedVersionFilesystem = versionMatch[1];
    }
  } catch (e) {}

  return cachedVersionFilesystem;
};

var versionFromReport = function versionFromReport() {
  var report = getReport();

  if (report.header && report.header.glibcVersionRuntime) {
    return report.header.glibcVersionRuntime;
  }

  return null;
};

var versionSuffix = function versionSuffix(s) {
  return s.trim().split(/\s+/)[1];
};

var versionFromCommand = function versionFromCommand(out) {
  var _out$split3 = out.split(/[\r\n]+/),
      _out$split4 = _slicedToArray(_out$split3, 3),
      getconf = _out$split4[0],
      ldd1 = _out$split4[1],
      ldd2 = _out$split4[2];

  if (getconf && getconf.includes(GLIBC)) {
    return versionSuffix(getconf);
  }

  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
    return versionSuffix(ldd2);
  }

  return null;
};
/**
 * Resolves with the libc version when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */


var version = function version() {
  var version, out;
  return regeneratorRuntime.async(function version$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          version = null;

          if (!isLinux()) {
            _context5.next = 11;
            break;
          }

          _context5.next = 4;
          return regeneratorRuntime.awrap(versionFromFilesystem());

        case 4:
          version = _context5.sent;

          if (!version) {
            version = versionFromReport();
          }

          if (version) {
            _context5.next = 11;
            break;
          }

          _context5.next = 9;
          return regeneratorRuntime.awrap(safeCommand());

        case 9:
          out = _context5.sent;
          version = versionFromCommand(out);

        case 11:
          return _context5.abrupt("return", version);

        case 12:
        case "end":
          return _context5.stop();
      }
    }
  });
};
/**
 * Returns the libc version when it can be determined, `null` otherwise.
 * @returns {?string}
 */


var versionSync = function versionSync() {
  var version = null;

  if (isLinux()) {
    version = versionFromFilesystemSync();

    if (!version) {
      version = versionFromReport();
    }

    if (!version) {
      var out = safeCommandSync();
      version = versionFromCommand(out);
    }
  }

  return version;
};

module.exports = {
  GLIBC: GLIBC,
  MUSL: MUSL,
  family: family,
  familySync: familySync,
  isNonGlibcLinux: isNonGlibcLinux,
  isNonGlibcLinuxSync: isNonGlibcLinuxSync,
  version: version,
  versionSync: versionSync
};