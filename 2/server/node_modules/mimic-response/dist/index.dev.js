'use strict'; // We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage

var knownProperties = ['aborted', 'complete', 'headers', 'httpVersion', 'httpVersionMinor', 'httpVersionMajor', 'method', 'rawHeaders', 'rawTrailers', 'setTimeout', 'socket', 'statusCode', 'statusMessage', 'trailers', 'url'];

module.exports = function (fromStream, toStream) {
  if (toStream._readableState.autoDestroy) {
    throw new Error('The second stream must have the `autoDestroy` option set to `false`');
  }

  var fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
  var properties = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var property = _step.value;

      // Don't overwrite existing properties.
      if (property in toStream) {
        return "continue";
      }

      properties[property] = {
        get: function get() {
          var value = fromStream[property];
          var isFunction = typeof value === 'function';
          return isFunction ? value.bind(fromStream) : value;
        },
        set: function set(value) {
          fromStream[property] = value;
        },
        enumerable: true,
        configurable: false
      };
    };

    for (var _iterator = fromProperties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  Object.defineProperties(toStream, properties);
  fromStream.once('aborted', function () {
    toStream.destroy();
    toStream.emit('aborted');
  });
  fromStream.once('close', function () {
    if (fromStream.complete) {
      if (toStream.readable) {
        toStream.once('end', function () {
          toStream.emit('close');
        });
      } else {
        toStream.emit('close');
      }
    } else {
      toStream.emit('close');
    }
  });
  return toStream;
};