"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var net_1 = __importDefault(require("net"));

var tls_1 = __importDefault(require("tls"));

var url_1 = __importDefault(require("url"));

var debug_1 = __importDefault(require("debug"));

var once_1 = __importDefault(require("@tootallnate/once"));

var agent_base_1 = require("agent-base");

var debug = debug_1["default"]('http-proxy-agent');

function isHTTPS(protocol) {
  return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
/**
 * The `HttpProxyAgent` implements an HTTP Agent subclass that connects
 * to the specified "HTTP proxy server" in order to proxy HTTP requests.
 *
 * @api public
 */


var HttpProxyAgent =
/*#__PURE__*/
function (_agent_base_1$Agent) {
  _inherits(HttpProxyAgent, _agent_base_1$Agent);

  function HttpProxyAgent(_opts) {
    var _this;

    _classCallCheck(this, HttpProxyAgent);

    var opts;

    if (typeof _opts === 'string') {
      opts = url_1["default"].parse(_opts);
    } else {
      opts = _opts;
    }

    if (!opts) {
      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
    }

    debug('Creating new HttpProxyAgent instance: %o', opts);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(HttpProxyAgent).call(this, opts));
    var proxy = Object.assign({}, opts); // If `true`, then connect to the proxy server over TLS.
    // Defaults to `false`.

    _this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol); // Prefer `hostname` over `host`, and set the `port` if needed.

    proxy.host = proxy.hostname || proxy.host;

    if (typeof proxy.port === 'string') {
      proxy.port = parseInt(proxy.port, 10);
    }

    if (!proxy.port && proxy.host) {
      proxy.port = _this.secureProxy ? 443 : 80;
    }

    if (proxy.host && proxy.path) {
      // If both a `host` and `path` are specified then it's most likely
      // the result of a `url.parse()` call... we need to remove the
      // `path` portion so that `net.connect()` doesn't attempt to open
      // that as a Unix socket file.
      delete proxy.path;
      delete proxy.pathname;
    }

    _this.proxy = proxy;
    return _this;
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   *
   * @api protected
   */


  _createClass(HttpProxyAgent, [{
    key: "callback",
    value: function callback(req, opts) {
      return __awaiter(this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var proxy, secureProxy, parsed, socket, first, endOfHeaders;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                proxy = this.proxy, secureProxy = this.secureProxy;
                parsed = url_1["default"].parse(req.path);

                if (!parsed.protocol) {
                  parsed.protocol = 'http:';
                }

                if (!parsed.hostname) {
                  parsed.hostname = opts.hostname || opts.host || null;
                }

                if (parsed.port == null && _typeof(opts.port)) {
                  parsed.port = String(opts.port);
                }

                if (parsed.port === '80') {
                  // if port is 80, then we can remove the port so that the
                  // ":80" portion is not on the produced URL
                  delete parsed.port;
                } // Change the `http.ClientRequest` instance's "path" field
                // to the absolute path of the URL that will be requested.


                req.path = url_1["default"].format(parsed); // Inject the `Proxy-Authorization` header if necessary.

                if (proxy.auth) {
                  req.setHeader('Proxy-Authorization', "Basic ".concat(Buffer.from(proxy.auth).toString('base64')));
                } // Create a socket connection to the proxy server.


                if (secureProxy) {
                  debug('Creating `tls.Socket`: %o', proxy);
                  socket = tls_1["default"].connect(proxy);
                } else {
                  debug('Creating `net.Socket`: %o', proxy);
                  socket = net_1["default"].connect(proxy);
                } // At this point, the http ClientRequest's internal `_header` field
                // might have already been set. If this is the case then we'll need
                // to re-generate the string since we just changed the `req.path`.


                if (req._header) {
                  debug('Regenerating stored HTTP header string for request');
                  req._header = null;

                  req._implicitHeader();

                  if (req.output && req.output.length > 0) {
                    // Node < 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.output[0];
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.output[0] = req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.output);
                  } else if (req.outputData && req.outputData.length > 0) {
                    // Node >= 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.outputData[0].data;
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.outputData[0].data = req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.outputData[0].data);
                  }
                } // Wait for the socket's `connect` event, so that this `callback()`
                // function throws instead of the `http` request machinery. This is
                // important for i.e. `PacProxyAgent` which determines a failed proxy
                // connection via the `callback()` function throwing.


                _context.next = 12;
                return once_1["default"](socket, 'connect');

              case 12:
                return _context.abrupt("return", socket);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }
  }]);

  return HttpProxyAgent;
}(agent_base_1.Agent);

exports["default"] = HttpProxyAgent;