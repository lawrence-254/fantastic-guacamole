"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('path'),
    dirname = _require.dirname,
    resolve = _require.resolve;

var fileURLToPath = require('./file-url-to-path/index.js');

var fs = require('../fs.js'); // given a path, find the owner of the nearest parent


var find = function find(path) {
  var resolved, stat;
  return regeneratorRuntime.async(function find$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (process.getuid) {
            _context.next = 2;
            break;
          }

          return _context.abrupt("return", {});

        case 2:
          // fs methods accept URL objects with a scheme of file: so we need to unwrap
          // those into an actual path string before we can resolve it
          resolved = path != null && path.href && path.origin ? resolve(fileURLToPath(path)) : resolve(path);
          _context.prev = 3;
          _context.next = 6;
          return regeneratorRuntime.awrap(fs.lstat(resolved));

        case 6:
          stat = _context.sent;

        case 7:
          _context.prev = 7;

          if (!stat) {
            _context.next = 10;
            break;
          }

          return _context.abrupt("return", {
            uid: stat.uid,
            gid: stat.gid
          });

        case 10:
          if (!(resolved !== dirname(resolved))) {
            _context.next = 12;
            break;
          }

          return _context.abrupt("return", find(dirname(resolved)));

        case 12:
          return _context.abrupt("return", {});

        case 14:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[3,, 7, 14]]);
}; // given a path, uid, and gid update the ownership of the path if necessary


var update = function update(path, uid, gid) {
  var stat;
  return regeneratorRuntime.async(function update$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(uid === undefined && gid === undefined)) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt("return");

        case 2:
          _context2.prev = 2;
          _context2.next = 5;
          return regeneratorRuntime.awrap(fs.stat(path));

        case 5:
          stat = _context2.sent;

          if (!(uid === stat.uid && gid === stat.gid)) {
            _context2.next = 8;
            break;
          }

          return _context2.abrupt("return");

        case 8:
          _context2.next = 12;
          break;

        case 10:
          _context2.prev = 10;
          _context2.t0 = _context2["catch"](2);

        case 12:
          _context2.prev = 12;
          _context2.next = 15;
          return regeneratorRuntime.awrap(fs.chown(path, uid, gid));

        case 15:
          _context2.next = 19;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t1 = _context2["catch"](12);

        case 19:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[2, 10], [12, 17]]);
}; // accepts a `path` and the `owner` property of an options object and normalizes
// it into an object with numerical `uid` and `gid`


var validate = function validate(path, input) {
  var uid, gid, owner;
  return regeneratorRuntime.async(function validate$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (typeof input === 'string' || typeof input === 'number') {
            uid = input;
            gid = input;
          } else if (input && _typeof(input) === 'object') {
            uid = input.uid;
            gid = input.gid;
          }

          if (!(uid === 'inherit' || gid === 'inherit')) {
            _context3.next = 7;
            break;
          }

          _context3.next = 4;
          return regeneratorRuntime.awrap(find(path));

        case 4:
          owner = _context3.sent;

          if (uid === 'inherit') {
            uid = owner.uid;
          }

          if (gid === 'inherit') {
            gid = owner.gid;
          }

        case 7:
          return _context3.abrupt("return", {
            uid: uid,
            gid: gid
          });

        case 8:
        case "end":
          return _context3.stop();
      }
    }
  });
};

module.exports = {
  find: find,
  update: update,
  validate: validate
};