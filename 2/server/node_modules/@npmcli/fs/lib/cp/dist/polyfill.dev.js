// this file is a modified version of the code in node 17.2.0
// which is, in turn, a modified version of the fs-extra module on npm
// node core changes:
// - Use of the assert module has been replaced with core's error system.
// - All code related to the glob dependency has been removed.
// - Bring your own custom fs module is not currently supported.
// - Some basic code cleanup.
// changes here:
// - remove all callback related code
// - drop sync support
// - change assertions back to non-internal methods (see options.js)
// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('../errors.js'),
    ERR_FS_CP_DIR_TO_NON_DIR = _require.ERR_FS_CP_DIR_TO_NON_DIR,
    ERR_FS_CP_EEXIST = _require.ERR_FS_CP_EEXIST,
    ERR_FS_CP_EINVAL = _require.ERR_FS_CP_EINVAL,
    ERR_FS_CP_FIFO_PIPE = _require.ERR_FS_CP_FIFO_PIPE,
    ERR_FS_CP_NON_DIR_TO_DIR = _require.ERR_FS_CP_NON_DIR_TO_DIR,
    ERR_FS_CP_SOCKET = _require.ERR_FS_CP_SOCKET,
    ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY = _require.ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
    ERR_FS_CP_UNKNOWN = _require.ERR_FS_CP_UNKNOWN,
    ERR_FS_EISDIR = _require.ERR_FS_EISDIR,
    ERR_INVALID_ARG_TYPE = _require.ERR_INVALID_ARG_TYPE;

var _require2 = require('os'),
    _require2$constants$e = _require2.constants.errno,
    EEXIST = _require2$constants$e.EEXIST,
    EISDIR = _require2$constants$e.EISDIR,
    EINVAL = _require2$constants$e.EINVAL,
    ENOTDIR = _require2$constants$e.ENOTDIR;

var _require3 = require('../fs.js'),
    chmod = _require3.chmod,
    copyFile = _require3.copyFile,
    lstat = _require3.lstat,
    mkdir = _require3.mkdir,
    readdir = _require3.readdir,
    readlink = _require3.readlink,
    stat = _require3.stat,
    symlink = _require3.symlink,
    unlink = _require3.unlink,
    utimes = _require3.utimes;

var _require4 = require('path'),
    dirname = _require4.dirname,
    isAbsolute = _require4.isAbsolute,
    join = _require4.join,
    parse = _require4.parse,
    resolve = _require4.resolve,
    sep = _require4.sep,
    toNamespacedPath = _require4.toNamespacedPath;

var _require5 = require('url'),
    fileURLToPath = _require5.fileURLToPath;

var defaultOptions = {
  dereference: false,
  errorOnExist: false,
  filter: undefined,
  force: true,
  preserveTimestamps: false,
  recursive: false
};

function cp(src, dest, opts) {
  return regeneratorRuntime.async(function cp$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(opts != null && _typeof(opts) !== 'object')) {
            _context.next = 2;
            break;
          }

          throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts);

        case 2:
          return _context.abrupt("return", cpFn(toNamespacedPath(getValidatedPath(src)), toNamespacedPath(getValidatedPath(dest)), _objectSpread({}, defaultOptions, {}, opts)));

        case 3:
        case "end":
          return _context.stop();
      }
    }
  });
}

function getValidatedPath(fileURLOrPath) {
  var path = fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;
  return path;
}

function cpFn(src, dest, opts) {
  var warning, stats, srcStat, destStat;
  return regeneratorRuntime.async(function cpFn$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          // Warn about using preserveTimestamps on 32-bit node
          // istanbul ignore next
          if (opts.preserveTimestamps && process.arch === 'ia32') {
            warning = 'Using the preserveTimestamps option in 32-bit ' + 'node is not recommended';
            process.emitWarning(warning, 'TimestampPrecisionWarning');
          }

          _context2.next = 3;
          return regeneratorRuntime.awrap(checkPaths(src, dest, opts));

        case 3:
          stats = _context2.sent;
          srcStat = stats.srcStat, destStat = stats.destStat;
          _context2.next = 7;
          return regeneratorRuntime.awrap(checkParentPaths(src, srcStat, dest));

        case 7:
          if (!opts.filter) {
            _context2.next = 9;
            break;
          }

          return _context2.abrupt("return", handleFilter(checkParentDir, destStat, src, dest, opts));

        case 9:
          return _context2.abrupt("return", checkParentDir(destStat, src, dest, opts));

        case 10:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function checkPaths(src, dest, opts) {
  var _ref, srcStat, destStat;

  return regeneratorRuntime.async(function checkPaths$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(getStats(src, dest, opts));

        case 2:
          _ref = _context3.sent;
          srcStat = _ref[0];
          destStat = _ref[1];

          if (!destStat) {
            _context3.next = 12;
            break;
          }

          if (!areIdentical(srcStat, destStat)) {
            _context3.next = 8;
            break;
          }

          throw new ERR_FS_CP_EINVAL({
            message: 'src and dest cannot be the same',
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 8:
          if (!(srcStat.isDirectory() && !destStat.isDirectory())) {
            _context3.next = 10;
            break;
          }

          throw new ERR_FS_CP_DIR_TO_NON_DIR({
            message: "cannot overwrite directory ".concat(src, " ") + "with non-directory ".concat(dest),
            path: dest,
            syscall: 'cp',
            errno: EISDIR
          });

        case 10:
          if (!(!srcStat.isDirectory() && destStat.isDirectory())) {
            _context3.next = 12;
            break;
          }

          throw new ERR_FS_CP_NON_DIR_TO_DIR({
            message: "cannot overwrite non-directory ".concat(src, " ") + "with directory ".concat(dest),
            path: dest,
            syscall: 'cp',
            errno: ENOTDIR
          });

        case 12:
          if (!(srcStat.isDirectory() && isSrcSubdir(src, dest))) {
            _context3.next = 14;
            break;
          }

          throw new ERR_FS_CP_EINVAL({
            message: "cannot copy ".concat(src, " to a subdirectory of self ").concat(dest),
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 14:
          return _context3.abrupt("return", {
            srcStat: srcStat,
            destStat: destStat
          });

        case 15:
        case "end":
          return _context3.stop();
      }
    }
  });
}

function areIdentical(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}

function getStats(src, dest, opts) {
  var statFunc = opts.dereference ? function (file) {
    return stat(file, {
      bigint: true
    });
  } : function (file) {
    return lstat(file, {
      bigint: true
    });
  };
  return Promise.all([statFunc(src), statFunc(dest)["catch"](function (err) {
    // istanbul ignore next: unsure how to cover.
    if (err.code === 'ENOENT') {
      return null;
    } // istanbul ignore next: unsure how to cover.


    throw err;
  })]);
}

function checkParentDir(destStat, src, dest, opts) {
  var destParent, dirExists;
  return regeneratorRuntime.async(function checkParentDir$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          destParent = dirname(dest);
          _context4.next = 3;
          return regeneratorRuntime.awrap(pathExists(destParent));

        case 3:
          dirExists = _context4.sent;

          if (!dirExists) {
            _context4.next = 6;
            break;
          }

          return _context4.abrupt("return", getStatsForCopy(destStat, src, dest, opts));

        case 6:
          _context4.next = 8;
          return regeneratorRuntime.awrap(mkdir(destParent, {
            recursive: true
          }));

        case 8:
          return _context4.abrupt("return", getStatsForCopy(destStat, src, dest, opts));

        case 9:
        case "end":
          return _context4.stop();
      }
    }
  });
}

function pathExists(dest) {
  return stat(dest).then(function () {
    return true;
  }, // istanbul ignore next: not sure when this would occur
  function (err) {
    return err.code === 'ENOENT' ? false : Promise.reject(err);
  });
} // Recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.


function checkParentPaths(src, srcStat, dest) {
  var srcParent, destParent, destStat;
  return regeneratorRuntime.async(function checkParentPaths$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          srcParent = resolve(dirname(src));
          destParent = resolve(dirname(dest));

          if (!(destParent === srcParent || destParent === parse(destParent).root)) {
            _context5.next = 4;
            break;
          }

          return _context5.abrupt("return");

        case 4:
          _context5.prev = 4;
          _context5.next = 7;
          return regeneratorRuntime.awrap(stat(destParent, {
            bigint: true
          }));

        case 7:
          destStat = _context5.sent;
          _context5.next = 15;
          break;

        case 10:
          _context5.prev = 10;
          _context5.t0 = _context5["catch"](4);

          if (!(_context5.t0.code === 'ENOENT')) {
            _context5.next = 14;
            break;
          }

          return _context5.abrupt("return");

        case 14:
          throw _context5.t0;

        case 15:
          if (!areIdentical(srcStat, destStat)) {
            _context5.next = 17;
            break;
          }

          throw new ERR_FS_CP_EINVAL({
            message: "cannot copy ".concat(src, " to a subdirectory of self ").concat(dest),
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 17:
          return _context5.abrupt("return", checkParentPaths(src, srcStat, destParent));

        case 18:
        case "end":
          return _context5.stop();
      }
    }
  }, null, null, [[4, 10]]);
}

var normalizePathToArray = function normalizePathToArray(path) {
  return resolve(path).split(sep).filter(Boolean);
}; // Return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.


function isSrcSubdir(src, dest) {
  var srcArr = normalizePathToArray(src);
  var destArr = normalizePathToArray(dest);
  return srcArr.every(function (cur, i) {
    return destArr[i] === cur;
  });
}

function handleFilter(onInclude, destStat, src, dest, opts, cb) {
  var include;
  return regeneratorRuntime.async(function handleFilter$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return regeneratorRuntime.awrap(opts.filter(src, dest));

        case 2:
          include = _context6.sent;

          if (!include) {
            _context6.next = 5;
            break;
          }

          return _context6.abrupt("return", onInclude(destStat, src, dest, opts, cb));

        case 5:
        case "end":
          return _context6.stop();
      }
    }
  });
}

function startCopy(destStat, src, dest, opts) {
  if (opts.filter) {
    return handleFilter(getStatsForCopy, destStat, src, dest, opts);
  }

  return getStatsForCopy(destStat, src, dest, opts);
}

function getStatsForCopy(destStat, src, dest, opts) {
  var statFn, srcStat;
  return regeneratorRuntime.async(function getStatsForCopy$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          statFn = opts.dereference ? stat : lstat;
          _context7.next = 3;
          return regeneratorRuntime.awrap(statFn(src));

        case 3:
          srcStat = _context7.sent;

          if (!(srcStat.isDirectory() && opts.recursive)) {
            _context7.next = 8;
            break;
          }

          return _context7.abrupt("return", onDir(srcStat, destStat, src, dest, opts));

        case 8:
          if (!srcStat.isDirectory()) {
            _context7.next = 12;
            break;
          }

          throw new ERR_FS_EISDIR({
            message: "".concat(src, " is a directory (not copied)"),
            path: src,
            syscall: 'cp',
            errno: EINVAL
          });

        case 12:
          if (!(srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())) {
            _context7.next = 16;
            break;
          }

          return _context7.abrupt("return", onFile(srcStat, destStat, src, dest, opts));

        case 16:
          if (!srcStat.isSymbolicLink()) {
            _context7.next = 20;
            break;
          }

          return _context7.abrupt("return", onLink(destStat, src, dest));

        case 20:
          if (!srcStat.isSocket()) {
            _context7.next = 24;
            break;
          }

          throw new ERR_FS_CP_SOCKET({
            message: "cannot copy a socket file: ".concat(dest),
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 24:
          if (!srcStat.isFIFO()) {
            _context7.next = 26;
            break;
          }

          throw new ERR_FS_CP_FIFO_PIPE({
            message: "cannot copy a FIFO pipe: ".concat(dest),
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 26:
          throw new ERR_FS_CP_UNKNOWN({
            message: "cannot copy an unknown file type: ".concat(dest),
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 27:
        case "end":
          return _context7.stop();
      }
    }
  });
}

function onFile(srcStat, destStat, src, dest, opts) {
  if (!destStat) {
    return _copyFile(srcStat, src, dest, opts);
  }

  return mayCopyFile(srcStat, src, dest, opts);
}

function mayCopyFile(srcStat, src, dest, opts) {
  return regeneratorRuntime.async(function mayCopyFile$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          if (!opts.force) {
            _context8.next = 6;
            break;
          }

          _context8.next = 3;
          return regeneratorRuntime.awrap(unlink(dest));

        case 3:
          return _context8.abrupt("return", _copyFile(srcStat, src, dest, opts));

        case 6:
          if (!opts.errorOnExist) {
            _context8.next = 8;
            break;
          }

          throw new ERR_FS_CP_EEXIST({
            message: "".concat(dest, " already exists"),
            path: dest,
            syscall: 'cp',
            errno: EEXIST
          });

        case 8:
        case "end":
          return _context8.stop();
      }
    }
  });
}

function _copyFile(srcStat, src, dest, opts) {
  return regeneratorRuntime.async(function _copyFile$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 2;
          return regeneratorRuntime.awrap(copyFile(src, dest));

        case 2:
          if (!opts.preserveTimestamps) {
            _context9.next = 4;
            break;
          }

          return _context9.abrupt("return", handleTimestampsAndMode(srcStat.mode, src, dest));

        case 4:
          return _context9.abrupt("return", setDestMode(dest, srcStat.mode));

        case 5:
        case "end":
          return _context9.stop();
      }
    }
  });
}

function handleTimestampsAndMode(srcMode, src, dest) {
  return regeneratorRuntime.async(function handleTimestampsAndMode$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          if (!fileIsNotWritable(srcMode)) {
            _context10.next = 4;
            break;
          }

          _context10.next = 3;
          return regeneratorRuntime.awrap(makeFileWritable(dest, srcMode));

        case 3:
          return _context10.abrupt("return", setDestTimestampsAndMode(srcMode, src, dest));

        case 4:
          return _context10.abrupt("return", setDestTimestampsAndMode(srcMode, src, dest));

        case 5:
        case "end":
          return _context10.stop();
      }
    }
  });
}

function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}

function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}

function setDestTimestampsAndMode(srcMode, src, dest) {
  return regeneratorRuntime.async(function setDestTimestampsAndMode$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.next = 2;
          return regeneratorRuntime.awrap(setDestTimestamps(src, dest));

        case 2:
          return _context11.abrupt("return", setDestMode(dest, srcMode));

        case 3:
        case "end":
          return _context11.stop();
      }
    }
  });
}

function setDestMode(dest, srcMode) {
  return chmod(dest, srcMode);
}

function setDestTimestamps(src, dest) {
  var updatedSrcStat;
  return regeneratorRuntime.async(function setDestTimestamps$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          _context12.next = 2;
          return regeneratorRuntime.awrap(stat(src));

        case 2:
          updatedSrcStat = _context12.sent;
          return _context12.abrupt("return", utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime));

        case 4:
        case "end":
          return _context12.stop();
      }
    }
  });
}

function onDir(srcStat, destStat, src, dest, opts) {
  if (!destStat) {
    return mkDirAndCopy(srcStat.mode, src, dest, opts);
  }

  return copyDir(src, dest, opts);
}

function mkDirAndCopy(srcMode, src, dest, opts) {
  return regeneratorRuntime.async(function mkDirAndCopy$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          _context13.next = 2;
          return regeneratorRuntime.awrap(mkdir(dest));

        case 2:
          _context13.next = 4;
          return regeneratorRuntime.awrap(copyDir(src, dest, opts));

        case 4:
          return _context13.abrupt("return", setDestMode(dest, srcMode));

        case 5:
        case "end":
          return _context13.stop();
      }
    }
  });
}

function copyDir(src, dest, opts) {
  var dir, i, item, srcItem, destItem, _ref2, destStat;

  return regeneratorRuntime.async(function copyDir$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          _context14.next = 2;
          return regeneratorRuntime.awrap(readdir(src));

        case 2:
          dir = _context14.sent;
          i = 0;

        case 4:
          if (!(i < dir.length)) {
            _context14.next = 17;
            break;
          }

          item = dir[i];
          srcItem = join(src, item);
          destItem = join(dest, item);
          _context14.next = 10;
          return regeneratorRuntime.awrap(checkPaths(srcItem, destItem, opts));

        case 10:
          _ref2 = _context14.sent;
          destStat = _ref2.destStat;
          _context14.next = 14;
          return regeneratorRuntime.awrap(startCopy(destStat, srcItem, destItem, opts));

        case 14:
          i++;
          _context14.next = 4;
          break;

        case 17:
        case "end":
          return _context14.stop();
      }
    }
  });
}

function onLink(destStat, src, dest) {
  var resolvedSrc, resolvedDest, srcStat;
  return regeneratorRuntime.async(function onLink$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          _context15.next = 2;
          return regeneratorRuntime.awrap(readlink(src));

        case 2:
          resolvedSrc = _context15.sent;

          if (!isAbsolute(resolvedSrc)) {
            resolvedSrc = resolve(dirname(src), resolvedSrc);
          }

          if (destStat) {
            _context15.next = 6;
            break;
          }

          return _context15.abrupt("return", symlink(resolvedSrc, dest));

        case 6:
          _context15.prev = 6;
          _context15.next = 9;
          return regeneratorRuntime.awrap(readlink(dest));

        case 9:
          resolvedDest = _context15.sent;
          _context15.next = 17;
          break;

        case 12:
          _context15.prev = 12;
          _context15.t0 = _context15["catch"](6);

          if (!(_context15.t0.code === 'EINVAL' || _context15.t0.code === 'UNKNOWN')) {
            _context15.next = 16;
            break;
          }

          return _context15.abrupt("return", symlink(resolvedSrc, dest));

        case 16:
          throw _context15.t0;

        case 17:
          if (!isAbsolute(resolvedDest)) {
            resolvedDest = resolve(dirname(dest), resolvedDest);
          }

          if (!isSrcSubdir(resolvedSrc, resolvedDest)) {
            _context15.next = 20;
            break;
          }

          throw new ERR_FS_CP_EINVAL({
            message: "cannot copy ".concat(resolvedSrc, " to a subdirectory of self ") + "".concat(resolvedDest),
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 20:
          _context15.next = 22;
          return regeneratorRuntime.awrap(stat(src));

        case 22:
          srcStat = _context15.sent;

          if (!(srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc))) {
            _context15.next = 25;
            break;
          }

          throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
            message: "cannot overwrite ".concat(resolvedDest, " with ").concat(resolvedSrc),
            path: dest,
            syscall: 'cp',
            errno: EINVAL
          });

        case 25:
          return _context15.abrupt("return", copyLink(resolvedSrc, dest));

        case 26:
        case "end":
          return _context15.stop();
      }
    }
  }, null, null, [[6, 12]]);
}

function copyLink(resolvedSrc, dest) {
  return regeneratorRuntime.async(function copyLink$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          _context16.next = 2;
          return regeneratorRuntime.awrap(unlink(dest));

        case 2:
          return _context16.abrupt("return", symlink(resolvedSrc, dest));

        case 3:
        case "end":
          return _context16.stop();
      }
    }
  });
}

module.exports = cp;