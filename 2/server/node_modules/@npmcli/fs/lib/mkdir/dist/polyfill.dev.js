"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('path'),
    dirname = _require.dirname;

var fileURLToPath = require('../common/file-url-to-path/index.js');

var fs = require('../fs.js');

var defaultOptions = {
  mode: 511,
  recursive: false
};

var mkdir = function mkdir(path, opts) {
  var options, makeDirectory;
  return regeneratorRuntime.async(function mkdir$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = _objectSpread({}, defaultOptions, {}, opts); // if we're not in recursive mode, just call the real mkdir with the path and
          // the mode option only

          if (options.recursive) {
            _context2.next = 3;
            break;
          }

          return _context2.abrupt("return", fs.mkdir(path, options.mode));

        case 3:
          makeDirectory = function makeDirectory(dir, mode) {
            var parent, made, stat;
            return regeneratorRuntime.async(function makeDirectory$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    // we can't use dirname directly since these functions support URL
                    // objects with the file: protocol as the path input, so first we get a
                    // string path, then we can call dirname on that
                    parent = dir != null && dir.href && dir.origin ? dirname(fileURLToPath(dir)) : dirname(dir); // if the parent is the dir itself, try to create it. anything but EISDIR
                    // should be rethrown

                    if (!(parent === dir)) {
                      _context.next = 12;
                      break;
                    }

                    _context.prev = 2;
                    _context.next = 5;
                    return regeneratorRuntime.awrap(fs.mkdir(dir, opts));

                  case 5:
                    _context.next = 11;
                    break;

                  case 7:
                    _context.prev = 7;
                    _context.t0 = _context["catch"](2);

                    if (!(_context.t0.code !== 'EISDIR')) {
                      _context.next = 11;
                      break;
                    }

                    throw _context.t0;

                  case 11:
                    return _context.abrupt("return", undefined);

                  case 12:
                    _context.prev = 12;
                    _context.next = 15;
                    return regeneratorRuntime.awrap(fs.mkdir(dir, mode));

                  case 15:
                    return _context.abrupt("return", dir);

                  case 18:
                    _context.prev = 18;
                    _context.t1 = _context["catch"](12);

                    if (!(_context.t1.code === 'ENOENT')) {
                      _context.next = 27;
                      break;
                    }

                    _context.next = 23;
                    return regeneratorRuntime.awrap(makeDirectory(parent, mode));

                  case 23:
                    made = _context.sent;
                    _context.next = 26;
                    return regeneratorRuntime.awrap(makeDirectory(dir, mode));

                  case 26:
                    return _context.abrupt("return", made);

                  case 27:
                    if (!(_context.t1.code !== 'EEXIST' && _context.t1.code !== 'EROFS')) {
                      _context.next = 29;
                      break;
                    }

                    throw _context.t1;

                  case 29:
                    _context.prev = 29;
                    _context.next = 32;
                    return regeneratorRuntime.awrap(fs.stat(dir));

                  case 32:
                    stat = _context.sent;

                    if (!stat.isDirectory()) {
                      _context.next = 35;
                      break;
                    }

                    return _context.abrupt("return", undefined);

                  case 35:
                    _context.next = 39;
                    break;

                  case 37:
                    _context.prev = 37;
                    _context.t2 = _context["catch"](29);

                  case 39:
                    throw _context.t1;

                  case 40:
                  case "end":
                    return _context.stop();
                }
              }
            }, null, null, [[2, 7], [12, 18], [29, 37]]);
          };

          return _context2.abrupt("return", makeDirectory(path, options.mode));

        case 5:
        case "end":
          return _context2.stop();
      }
    }
  });
};

module.exports = mkdir;