"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// this file is a modified version of the code in node core >=14.14.0
// which is, in turn, a modified version of the rimraf module on npm
// node core changes:
// - Use of the assert module has been replaced with core's error system.
// - All code related to the glob dependency has been removed.
// - Bring your own custom fs module is not currently supported.
// - Some basic code cleanup.
// changes here:
// - remove all callback related code
// - drop sync support
// - change assertions back to non-internal methods (see options.js)
// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows
var errnos = require('os').constants.errno;

var _require = require('path'),
    join = _require.join;

var fs = require('../fs.js'); // error codes that mean we need to remove contents


var notEmptyCodes = new Set(['ENOTEMPTY', 'EEXIST', 'EPERM']); // error codes we can retry later

var retryCodes = new Set(['EBUSY', 'EMFILE', 'ENFILE', 'ENOTEMPTY', 'EPERM']);
var isWindows = process.platform === 'win32';
var defaultOptions = {
  retryDelay: 100,
  maxRetries: 0,
  recursive: false,
  force: false
}; // this is drastically simplified, but should be roughly equivalent to what
// node core throws

var ERR_FS_EISDIR =
/*#__PURE__*/
function (_Error) {
  _inherits(ERR_FS_EISDIR, _Error);

  function ERR_FS_EISDIR(path) {
    var _this;

    _classCallCheck(this, ERR_FS_EISDIR);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ERR_FS_EISDIR).call(this));
    _this.info = {
      code: 'EISDIR',
      message: 'is a directory',
      path: path,
      syscall: 'rm',
      errno: errnos.EISDIR
    };
    _this.name = 'SystemError';
    _this.code = 'ERR_FS_EISDIR';
    _this.errno = errnos.EISDIR;
    _this.syscall = 'rm';
    _this.path = path;
    _this.message = "Path is a directory: ".concat(_this.syscall, " returned ") + "".concat(_this.info.code, " (is a directory) ").concat(path);
    return _this;
  }

  _createClass(ERR_FS_EISDIR, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }]);

  return ERR_FS_EISDIR;
}(_wrapNativeSuper(Error));

var ENOTDIR =
/*#__PURE__*/
function (_Error2) {
  _inherits(ENOTDIR, _Error2);

  function ENOTDIR(path) {
    var _this2;

    _classCallCheck(this, ENOTDIR);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ENOTDIR).call(this));
    _this2.name = 'Error';
    _this2.code = 'ENOTDIR';
    _this2.errno = errnos.ENOTDIR;
    _this2.syscall = 'rmdir';
    _this2.path = path;
    _this2.message = "not a directory, ".concat(_this2.syscall, " '").concat(_this2.path, "'");
    return _this2;
  }

  _createClass(ENOTDIR, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, ": ").concat(this.code, ": ").concat(this.message);
    }
  }]);

  return ENOTDIR;
}(_wrapNativeSuper(Error)); // force is passed separately here because we respect it for the first entry
// into rimraf only, any further calls that are spawned as a result (i.e. to
// delete content within the target) will ignore ENOENT errors


var rimraf = function rimraf(path, options) {
  var isTop,
      force,
      stat,
      _args = arguments;
  return regeneratorRuntime.async(function rimraf$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          isTop = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
          force = isTop ? options.force : true;
          _context.next = 4;
          return regeneratorRuntime.awrap(fs.lstat(path)["catch"](function (err) {
            // we only ignore ENOENT if we're forcing this call
            if (err.code === 'ENOENT' && force) {
              return;
            }

            if (isWindows && err.code === 'EPERM') {
              return fixEPERM(path, options, err, isTop);
            }

            throw err;
          }));

        case 4:
          stat = _context.sent;

          if (stat) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return");

        case 7:
          if (!stat.isDirectory()) {
            _context.next = 9;
            break;
          }

          return _context.abrupt("return", rmdir(path, options, null, isTop));

        case 9:
          return _context.abrupt("return", fs.unlink(path)["catch"](function (err) {
            if (err.code === 'ENOENT' && force) {
              return;
            }

            if (err.code === 'EISDIR') {
              return rmdir(path, options, err, isTop);
            }

            if (err.code === 'EPERM') {
              // in windows, we handle this through fixEPERM which will also try to
              // delete things again. everywhere else since deleting the target as a
              // file didn't work we go ahead and try to delete it as a directory
              return isWindows ? fixEPERM(path, options, err, isTop) : rmdir(path, options, err, isTop);
            }

            throw err;
          }));

        case 10:
        case "end":
          return _context.stop();
      }
    }
  });
};

var fixEPERM = function fixEPERM(path, options, originalErr, isTop) {
  var force, targetMissing, stat;
  return regeneratorRuntime.async(function fixEPERM$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          force = isTop ? options.force : true;
          _context2.next = 3;
          return regeneratorRuntime.awrap(fs.chmod(path, 438)["catch"](function (err) {
            if (err.code === 'ENOENT' && force) {
              return true;
            }

            throw originalErr;
          }));

        case 3:
          targetMissing = _context2.sent;

          if (!targetMissing) {
            _context2.next = 6;
            break;
          }

          return _context2.abrupt("return");

        case 6:
          _context2.next = 8;
          return regeneratorRuntime.awrap(fs.lstat(path)["catch"](function (err) {
            if (err.code === 'ENOENT' && force) {
              return;
            }

            throw originalErr;
          }));

        case 8:
          stat = _context2.sent;

          if (stat) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt("return");

        case 11:
          if (!stat.isDirectory()) {
            _context2.next = 13;
            break;
          }

          return _context2.abrupt("return", rmdir(path, options, originalErr, isTop));

        case 13:
          return _context2.abrupt("return", fs.unlink(path));

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  });
};

var rmdir = function rmdir(path, options, originalErr, isTop) {
  var force;
  return regeneratorRuntime.async(function rmdir$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!(!options.recursive && isTop)) {
            _context4.next = 2;
            break;
          }

          throw originalErr || new ERR_FS_EISDIR(path);

        case 2:
          force = isTop ? options.force : true;
          return _context4.abrupt("return", fs.rmdir(path)["catch"](function _callee(err) {
            var stillExists, files;
            return regeneratorRuntime.async(function _callee$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!(isWindows && err.code === 'ENOENT')) {
                      _context3.next = 5;
                      break;
                    }

                    _context3.next = 3;
                    return regeneratorRuntime.awrap(fs.lstat(path).then(function () {
                      return true;
                    }, function () {
                      return false;
                    }));

                  case 3:
                    stillExists = _context3.sent;

                    if (stillExists) {
                      err = new ENOTDIR(path);
                    }

                  case 5:
                    if (!(err.code === 'ENOENT' && force)) {
                      _context3.next = 7;
                      break;
                    }

                    return _context3.abrupt("return");

                  case 7:
                    if (!(originalErr && err.code === 'ENOTDIR')) {
                      _context3.next = 9;
                      break;
                    }

                    throw originalErr;

                  case 9:
                    if (!notEmptyCodes.has(err.code)) {
                      _context3.next = 16;
                      break;
                    }

                    _context3.next = 12;
                    return regeneratorRuntime.awrap(fs.readdir(path));

                  case 12:
                    files = _context3.sent;
                    _context3.next = 15;
                    return regeneratorRuntime.awrap(Promise.all(files.map(function (file) {
                      var target = join(path, file);
                      return rimraf(target, options);
                    })));

                  case 15:
                    return _context3.abrupt("return", fs.rmdir(path));

                  case 16:
                    throw err;

                  case 17:
                  case "end":
                    return _context3.stop();
                }
              }
            });
          }));

        case 4:
        case "end":
          return _context4.stop();
      }
    }
  });
};

var rm = function rm(path, opts) {
  var options, retries, errHandler;
  return regeneratorRuntime.async(function rm$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          options = _objectSpread({}, defaultOptions, {}, opts);
          retries = 0;

          errHandler = function errHandler(err) {
            var delay;
            return regeneratorRuntime.async(function errHandler$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(retryCodes.has(err.code) && ++retries < options.maxRetries)) {
                      _context5.next = 5;
                      break;
                    }

                    delay = retries * options.retryDelay;
                    _context5.next = 4;
                    return regeneratorRuntime.awrap(promiseTimeout(delay));

                  case 4:
                    return _context5.abrupt("return", rimraf(path, options, true)["catch"](errHandler));

                  case 5:
                    throw err;

                  case 6:
                  case "end":
                    return _context5.stop();
                }
              }
            });
          };

          return _context6.abrupt("return", rimraf(path, options, true)["catch"](errHandler));

        case 4:
        case "end":
          return _context6.stop();
      }
    }
  });
};

var promiseTimeout = function promiseTimeout(ms) {
  return new Promise(function (r) {
    return setTimeout(r, ms);
  });
};

module.exports = rm;