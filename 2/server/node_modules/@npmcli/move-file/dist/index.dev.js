"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('path'),
    dirname = _require.dirname,
    join = _require.join,
    resolve = _require.resolve,
    relative = _require.relative,
    isAbsolute = _require.isAbsolute;

var rimraf_ = require('rimraf');

var _require2 = require('util'),
    promisify = _require2.promisify;

var _require3 = require('fs'),
    access_ = _require3.access,
    accessSync = _require3.accessSync,
    copyFile_ = _require3.copyFile,
    copyFileSync = _require3.copyFileSync,
    unlink_ = _require3.unlink,
    unlinkSync = _require3.unlinkSync,
    readdir_ = _require3.readdir,
    readdirSync = _require3.readdirSync,
    rename_ = _require3.rename,
    renameSync = _require3.renameSync,
    stat_ = _require3.stat,
    statSync = _require3.statSync,
    lstat_ = _require3.lstat,
    lstatSync = _require3.lstatSync,
    symlink_ = _require3.symlink,
    symlinkSync = _require3.symlinkSync,
    readlink_ = _require3.readlink,
    readlinkSync = _require3.readlinkSync;

var access = promisify(access_);
var copyFile = promisify(copyFile_);
var unlink = promisify(unlink_);
var readdir = promisify(readdir_);
var rename = promisify(rename_);
var stat = promisify(stat_);
var lstat = promisify(lstat_);
var symlink = promisify(symlink_);
var readlink = promisify(readlink_);
var rimraf = promisify(rimraf_);
var rimrafSync = rimraf_.sync;

var mkdirp = require('mkdirp');

var pathExists = function pathExists(path) {
  return regeneratorRuntime.async(function pathExists$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return regeneratorRuntime.awrap(access(path));

        case 3:
          return _context.abrupt("return", true);

        case 6:
          _context.prev = 6;
          _context.t0 = _context["catch"](0);
          return _context.abrupt("return", _context.t0.code !== 'ENOENT');

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[0, 6]]);
};

var pathExistsSync = function pathExistsSync(path) {
  try {
    accessSync(path);
    return true;
  } catch (er) {
    return er.code !== 'ENOENT';
  }
};

var moveFile = function moveFile(source, destination) {
  var options,
      root,
      symlinks,
      sourceStat,
      files,
      _args3 = arguments;
  return regeneratorRuntime.async(function moveFile$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
          root = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : true;
          symlinks = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : [];

          if (!(!source || !destination)) {
            _context3.next = 5;
            break;
          }

          throw new TypeError('`source` and `destination` file required');

        case 5:
          options = _objectSpread({
            overwrite: true
          }, options);
          _context3.t0 = !options.overwrite;

          if (!_context3.t0) {
            _context3.next = 11;
            break;
          }

          _context3.next = 10;
          return regeneratorRuntime.awrap(pathExists(destination));

        case 10:
          _context3.t0 = _context3.sent;

        case 11:
          if (!_context3.t0) {
            _context3.next = 13;
            break;
          }

          throw new Error("The destination file exists: ".concat(destination));

        case 13:
          _context3.next = 15;
          return regeneratorRuntime.awrap(mkdirp(dirname(destination)));

        case 15:
          _context3.prev = 15;
          _context3.next = 18;
          return regeneratorRuntime.awrap(rename(source, destination));

        case 18:
          _context3.next = 43;
          break;

        case 20:
          _context3.prev = 20;
          _context3.t1 = _context3["catch"](15);

          if (!(_context3.t1.code === 'EXDEV' || _context3.t1.code === 'EPERM')) {
            _context3.next = 42;
            break;
          }

          _context3.next = 25;
          return regeneratorRuntime.awrap(lstat(source));

        case 25:
          sourceStat = _context3.sent;

          if (!sourceStat.isDirectory()) {
            _context3.next = 34;
            break;
          }

          _context3.next = 29;
          return regeneratorRuntime.awrap(readdir(source));

        case 29:
          files = _context3.sent;
          _context3.next = 32;
          return regeneratorRuntime.awrap(Promise.all(files.map(function (file) {
            return moveFile(join(source, file), join(destination, file), options, false, symlinks);
          })));

        case 32:
          _context3.next = 40;
          break;

        case 34:
          if (!sourceStat.isSymbolicLink()) {
            _context3.next = 38;
            break;
          }

          symlinks.push({
            source: source,
            destination: destination
          });
          _context3.next = 40;
          break;

        case 38:
          _context3.next = 40;
          return regeneratorRuntime.awrap(copyFile(source, destination));

        case 40:
          _context3.next = 43;
          break;

        case 42:
          throw _context3.t1;

        case 43:
          if (!root) {
            _context3.next = 48;
            break;
          }

          _context3.next = 46;
          return regeneratorRuntime.awrap(Promise.all(symlinks.map(function _callee(_ref) {
            var source, destination, target, targetStat;
            return regeneratorRuntime.async(function _callee$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    source = _ref.source, destination = _ref.destination;
                    _context2.next = 3;
                    return regeneratorRuntime.awrap(readlink(source));

                  case 3:
                    target = _context2.sent;
                    // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination
                    if (isAbsolute(target)) target = resolve(destination, relative(source, target)); // try to determine what the actual file is so we can create the correct type of symlink in windows

                    _context2.prev = 5;
                    _context2.next = 8;
                    return regeneratorRuntime.awrap(stat(resolve(dirname(source), target)));

                  case 8:
                    targetStat = _context2.sent;
                    _context2.next = 13;
                    break;

                  case 11:
                    _context2.prev = 11;
                    _context2.t0 = _context2["catch"](5);

                  case 13:
                    _context2.next = 15;
                    return regeneratorRuntime.awrap(symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file'));

                  case 15:
                  case "end":
                    return _context2.stop();
                }
              }
            }, null, null, [[5, 11]]);
          })));

        case 46:
          _context3.next = 48;
          return regeneratorRuntime.awrap(rimraf(source));

        case 48:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, [[15, 20]]);
};

var moveFileSync = function moveFileSync(source, destination) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var symlinks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

  if (!source || !destination) {
    throw new TypeError('`source` and `destination` file required');
  }

  options = _objectSpread({
    overwrite: true
  }, options);

  if (!options.overwrite && pathExistsSync(destination)) {
    throw new Error("The destination file exists: ".concat(destination));
  }

  mkdirp.sync(dirname(destination));

  try {
    renameSync(source, destination);
  } catch (error) {
    if (error.code === 'EXDEV' || error.code === 'EPERM') {
      var sourceStat = lstatSync(source);

      if (sourceStat.isDirectory()) {
        var files = readdirSync(source);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var file = _step.value;
            moveFileSync(join(source, file), join(destination, file), options, false, symlinks);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (sourceStat.isSymbolicLink()) {
        symlinks.push({
          source: source,
          destination: destination
        });
      } else {
        copyFileSync(source, destination);
      }
    } else {
      throw error;
    }
  }

  if (root) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = symlinks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _step2$value = _step2.value,
            _source = _step2$value.source,
            _destination = _step2$value.destination;
        var target = readlinkSync(_source); // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination

        if (isAbsolute(target)) target = resolve(_destination, relative(_source, target)); // try to determine what the actual file is so we can create the correct type of symlink in windows

        var targetStat = void 0;

        try {
          targetStat = statSync(resolve(dirname(_source), target));
        } catch (err) {}

        symlinkSync(target, _destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file');
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    rimrafSync(source);
  }
};

module.exports = moveFile;
module.exports.sync = moveFileSync;