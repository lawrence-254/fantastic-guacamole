'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Minipass = require('minipass');

var MinipassSized = require('minipass-sized');

var Blob = require('./blob.js');

var BUFFER = Blob.BUFFER;

var FetchError = require('./fetch-error.js'); // optional dependency on 'encoding'


var convert;

try {
  convert = require('encoding').convert;
} catch (e) {}

var INTERNALS = Symbol('Body internals');
var CONSUME_BODY = Symbol('consumeBody');

var Body =
/*#__PURE__*/
function () {
  function Body(bodyArg) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Body);

    var _options$size = options.size,
        size = _options$size === void 0 ? 0 : _options$size,
        _options$timeout = options.timeout,
        timeout = _options$timeout === void 0 ? 0 : _options$timeout;
    var body = bodyArg === undefined || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]' ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));
    this[INTERNALS] = {
      body: body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;

    if (Minipass.isStream(body)) {
      body.on('error', function (er) {
        var error = er.name === 'AbortError' ? er : new FetchError("Invalid response while trying to fetch ".concat(_this.url, ": ").concat(er.message), 'system', er);
        _this[INTERNALS].error = error;
      });
    }
  }

  _createClass(Body, [{
    key: "arrayBuffer",
    value: function arrayBuffer() {
      return this[CONSUME_BODY]().then(function (buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    }
  }, {
    key: "blob",
    value: function blob() {
      var ct = this.headers && this.headers.get('content-type') || '';
      return this[CONSUME_BODY]().then(function (buf) {
        return Object.assign(new Blob([], {
          type: ct.toLowerCase()
        }), _defineProperty({}, BUFFER, buf));
      });
    }
  }, {
    key: "json",
    value: function json() {
      var _this2 = this;

      return this[CONSUME_BODY]().then(function (buf) {
        try {
          return JSON.parse(buf.toString());
        } catch (er) {
          return Promise.reject(new FetchError("invalid json response body at ".concat(_this2.url, " reason: ").concat(er.message), 'invalid-json'));
        }
      });
    }
  }, {
    key: "text",
    value: function text() {
      return this[CONSUME_BODY]().then(function (buf) {
        return buf.toString();
      });
    }
  }, {
    key: "buffer",
    value: function buffer() {
      return this[CONSUME_BODY]();
    }
  }, {
    key: "textConverted",
    value: function textConverted() {
      var _this3 = this;

      return this[CONSUME_BODY]().then(function (buf) {
        return convertBody(buf, _this3.headers);
      });
    }
  }, {
    key: CONSUME_BODY,
    value: function value() {
      var _this4 = this;

      if (this[INTERNALS].disturbed) return Promise.reject(new TypeError("body used already for: ".concat(this.url)));
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) return Promise.reject(this[INTERNALS].error); // body is null

      if (this.body === null) {
        return Promise.resolve(Buffer.alloc(0));
      }

      if (Buffer.isBuffer(this.body)) return Promise.resolve(this.body);
      var upstream = isBlob(this.body) ? this.body.stream() : this.body;
      /* istanbul ignore if: should never happen */

      if (!Minipass.isStream(upstream)) return Promise.resolve(Buffer.alloc(0));
      var stream = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({
        size: this.size
      }) : new Minipass(); // allow timeout on slow response body

      var resTimeout = this.timeout ? setTimeout(function () {
        stream.emit('error', new FetchError("Response timeout while trying to fetch ".concat(_this4.url, " (over ").concat(_this4.timeout, "ms)"), 'body-timeout'));
      }, this.timeout) : null; // do not keep the process open just for this timeout, even
      // though we expect it'll get cleared eventually.

      if (resTimeout) {
        resTimeout.unref();
      } // do the pipe in the promise, because the pipe() can send too much
      // data through right away and upset the MP Sized object


      return new Promise(function (resolve, reject) {
        // if the stream is some other kind of stream, then pipe through a MP
        // so we can collect it more easily.
        if (stream !== upstream) {
          upstream.on('error', function (er) {
            return stream.emit('error', er);
          });
          upstream.pipe(stream);
        }

        resolve();
      }).then(function () {
        return stream.concat();
      }).then(function (buf) {
        clearTimeout(resTimeout);
        return buf;
      })["catch"](function (er) {
        clearTimeout(resTimeout); // request was aborted, reject with this Error

        if (er.name === 'AbortError' || er.name === 'FetchError') throw er;else if (er.name === 'RangeError') throw new FetchError("Could not create Buffer from response body for ".concat(_this4.url, ": ").concat(er.message), 'system', er);else // other errors, such as incorrect content-encoding or content-length
          throw new FetchError("Invalid response body while trying to fetch ".concat(_this4.url, ": ").concat(er.message), 'system', er);
      });
    }
  }, {
    key: "body",
    get: function get() {
      return this[INTERNALS].body;
    }
  }, {
    key: "bodyUsed",
    get: function get() {
      return this[INTERNALS].disturbed;
    }
  }], [{
    key: "clone",
    value: function clone(instance) {
      if (instance.bodyUsed) throw new Error('cannot clone body after it is used');
      var body = instance.body; // check that body is a stream and not form-data object
      // NB: can't clone the form-data object without having it as a dependency

      if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {
        // create a dedicated tee stream so that we don't lose data
        // potentially sitting in the body stream's buffer by writing it
        // immediately to p1 and not having it for p2.
        var tee = new Minipass();
        var p1 = new Minipass();
        var p2 = new Minipass();
        tee.on('error', function (er) {
          p1.emit('error', er);
          p2.emit('error', er);
        });
        body.on('error', function (er) {
          return tee.emit('error', er);
        });
        tee.pipe(p1);
        tee.pipe(p2);
        body.pipe(tee); // set instance body to one fork, return the other

        instance[INTERNALS].body = p1;
        return p2;
      } else return instance.body;
    }
  }, {
    key: "extractContentType",
    value: function extractContentType(body) {
      return body === null || body === undefined ? null : typeof body === 'string' ? 'text/plain;charset=UTF-8' : isURLSearchParams(body) ? 'application/x-www-form-urlencoded;charset=UTF-8' : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === 'function' ? "multipart/form-data;boundary=".concat(body.getBoundary()) : Minipass.isStream(body) ? null : 'text/plain;charset=UTF-8';
    }
  }, {
    key: "getTotalBytes",
    value: function getTotalBytes(instance) {
      var body = instance.body;
      return body === null || body === undefined ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === 'function' && ( // detect form data input from form-data module
      body._lengthRetrievers &&
      /* istanbul ignore next */
      body._lengthRetrievers.length == 0 || // 1.x
      body.hasKnownLength && body.hasKnownLength()) // 2.x
      ? body.getLengthSync() : null;
    }
  }, {
    key: "writeToStream",
    value: function writeToStream(dest, instance) {
      var body = instance.body;
      if (body === null || body === undefined) dest.end();else if (Buffer.isBuffer(body) || typeof body === 'string') dest.end(body);else {
        // body is stream or blob
        var stream = isBlob(body) ? body.stream() : body;
        stream.on('error', function (er) {
          return dest.emit('error', er);
        }).pipe(dest);
      }
      return dest;
    }
  }]);

  return Body;
}();

Object.defineProperties(Body.prototype, {
  body: {
    enumerable: true
  },
  bodyUsed: {
    enumerable: true
  },
  arrayBuffer: {
    enumerable: true
  },
  blob: {
    enumerable: true
  },
  json: {
    enumerable: true
  },
  text: {
    enumerable: true
  }
});

var isURLSearchParams = function isURLSearchParams(obj) {
  return (// Duck-typing as a necessary condition.
    _typeof(obj) !== 'object' || typeof obj.append !== 'function' || typeof obj["delete"] !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function' ? false // Brand-checking and more duck-typing as optional condition.
    : obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function'
  );
};

var isBlob = function isBlob(obj) {
  return _typeof(obj) === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
};

var convertBody = function convertBody(buffer, headers) {
  /* istanbul ignore if */
  if (typeof convert !== 'function') throw new Error('The package `encoding` must be installed to use the textConverted() function');
  var ct = headers && headers.get('content-type');
  var charset = 'utf-8';
  var res, str; // header

  if (ct) res = /charset=([^;]*)/i.exec(ct); // no charset in content type, peek at response body for at most 1024 bytes

  str = buffer.slice(0, 1024).toString(); // html5

  if (!res && str) res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str); // html4

  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);

    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) res.pop(); // drop last quote
    }

    if (res) res = /charset=(.*)/i.exec(res.pop());
  } // xml


  if (!res && str) res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str); // found charset

  if (res) {
    charset = res.pop(); // prevent decode issues when sites use incorrect encoding
    // ref: https://hsivonen.fi/encoding-menu/

    if (charset === 'gb2312' || charset === 'gbk') charset = 'gb18030';
  } // turn raw buffers into a single utf-8 buffer


  return convert(buffer, 'UTF-8', charset).toString();
};

module.exports = Body;