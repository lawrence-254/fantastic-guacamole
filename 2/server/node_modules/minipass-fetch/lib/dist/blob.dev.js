'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Minipass = require('minipass');

var TYPE = Symbol('type');
var BUFFER = Symbol('buffer');

var Blob =
/*#__PURE__*/
function () {
  function Blob(blobParts, options) {
    _classCallCheck(this, Blob);

    this[TYPE] = '';
    var buffers = [];
    var size = 0;

    if (blobParts) {
      var a = blobParts;
      var length = Number(a.length);

      for (var i = 0; i < length; i++) {
        var element = a[i];
        var buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof Blob ? element[BUFFER] : typeof element === 'string' ? Buffer.from(element) : Buffer.from(String(element));
        size += buffer.length;
        buffers.push(buffer);
      }
    }

    this[BUFFER] = Buffer.concat(buffers, size);
    var type = options && options.type !== undefined && String(options.type).toLowerCase();

    if (type && !/[^\u0020-\u007E]/.test(type)) {
      this[TYPE] = type;
    }
  }

  _createClass(Blob, [{
    key: "text",
    value: function text() {
      return Promise.resolve(this[BUFFER].toString());
    }
  }, {
    key: "arrayBuffer",
    value: function arrayBuffer() {
      var buf = this[BUFFER];
      var off = buf.byteOffset;
      var len = buf.byteLength;
      var ab = buf.buffer.slice(off, off + len);
      return Promise.resolve(ab);
    }
  }, {
    key: "stream",
    value: function stream() {
      return new Minipass().end(this[BUFFER]);
    }
  }, {
    key: "slice",
    value: function slice(start, end, type) {
      var size = this.size;
      var relativeStart = start === undefined ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
      var relativeEnd = end === undefined ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
      var span = Math.max(relativeEnd - relativeStart, 0);
      var buffer = this[BUFFER];
      var slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      var blob = new Blob([], {
        type: type
      });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }, {
    key: "size",
    get: function get() {
      return this[BUFFER].length;
    }
  }, {
    key: "type",
    get: function get() {
      return this[TYPE];
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Blob';
    }
  }], [{
    key: "BUFFER",
    get: function get() {
      return BUFFER;
    }
  }]);

  return Blob;
}();

Object.defineProperties(Blob.prototype, {
  size: {
    enumerable: true
  },
  type: {
    enumerable: true
  }
});
module.exports = Blob;