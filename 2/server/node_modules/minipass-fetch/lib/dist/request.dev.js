'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Url = require('url');

var Minipass = require('minipass');

var Headers = require('./headers.js');

var exportNodeCompatibleHeaders = Headers.exportNodeCompatibleHeaders;

var Body = require('./body.js');

var clone = Body.clone,
    extractContentType = Body.extractContentType,
    getTotalBytes = Body.getTotalBytes;

var version = require('../package.json').version;

var defaultUserAgent = "minipass-fetch/".concat(version, " (+https://github.com/isaacs/minipass-fetch)");
var INTERNALS = Symbol('Request internals');
var parseUrl = Url.parse,
    formatUrl = Url.format;

var isRequest = function isRequest(input) {
  return _typeof(input) === 'object' && _typeof(input[INTERNALS]) === 'object';
};

var isAbortSignal = function isAbortSignal(signal) {
  var proto = signal && _typeof(signal) === 'object' && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === 'AbortSignal');
};

var Request =
/*#__PURE__*/
function (_Body) {
  _inherits(Request, _Body);

  function Request(input) {
    var _this;

    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Request);

    var parsedURL = isRequest(input) ? Url.parse(input.url) : input && input.href ? Url.parse(input.href) : Url.parse("".concat(input));
    if (isRequest(input)) init = _objectSpread({}, input[INTERNALS], {}, init);else if (!input || typeof input === 'string') input = {};
    var method = (init.method || input.method || 'GET').toUpperCase();
    var isGETHEAD = method === 'GET' || method === 'HEAD';
    if ((init.body !== null && init.body !== undefined || isRequest(input) && input.body !== null) && isGETHEAD) throw new TypeError('Request with GET/HEAD method cannot have body');
    var inputBody = init.body !== null && init.body !== undefined ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Request).call(this, inputBody, {
      timeout: init.timeout || input.timeout || 0,
      size: init.size || input.size || 0
    }));
    var headers = new Headers(init.headers || input.headers || {});

    if (inputBody !== null && inputBody !== undefined && !headers.has('Content-Type')) {
      var contentType = extractContentType(inputBody);
      if (contentType) headers.append('Content-Type', contentType);
    }

    var signal = 'signal' in init ? init.signal : null;
    if (signal !== null && signal !== undefined && !isAbortSignal(signal)) throw new TypeError('Expected signal must be an instanceof AbortSignal'); // TLS specific options that are handled by node

    var _init = init,
        ca = _init.ca,
        cert = _init.cert,
        ciphers = _init.ciphers,
        clientCertEngine = _init.clientCertEngine,
        crl = _init.crl,
        dhparam = _init.dhparam,
        ecdhCurve = _init.ecdhCurve,
        family = _init.family,
        honorCipherOrder = _init.honorCipherOrder,
        key = _init.key,
        passphrase = _init.passphrase,
        pfx = _init.pfx,
        _init$rejectUnauthori = _init.rejectUnauthorized,
        rejectUnauthorized = _init$rejectUnauthori === void 0 ? process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0' : _init$rejectUnauthori,
        secureOptions = _init.secureOptions,
        secureProtocol = _init.secureProtocol,
        servername = _init.servername,
        sessionIdContext = _init.sessionIdContext;
    _this[INTERNALS] = {
      method: method,
      redirect: init.redirect || input.redirect || 'follow',
      headers: headers,
      parsedURL: parsedURL,
      signal: signal,
      ca: ca,
      cert: cert,
      ciphers: ciphers,
      clientCertEngine: clientCertEngine,
      crl: crl,
      dhparam: dhparam,
      ecdhCurve: ecdhCurve,
      family: family,
      honorCipherOrder: honorCipherOrder,
      key: key,
      passphrase: passphrase,
      pfx: pfx,
      rejectUnauthorized: rejectUnauthorized,
      secureOptions: secureOptions,
      secureProtocol: secureProtocol,
      servername: servername,
      sessionIdContext: sessionIdContext
    }; // node-fetch-only options

    _this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
    _this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
    _this.counter = init.counter || input.counter || 0;
    _this.agent = init.agent || input.agent;
    return _this;
  }

  _createClass(Request, [{
    key: "clone",
    value: function clone() {
      return new Request(this);
    }
  }, {
    key: "method",
    get: function get() {
      return this[INTERNALS].method;
    }
  }, {
    key: "url",
    get: function get() {
      return formatUrl(this[INTERNALS].parsedURL);
    }
  }, {
    key: "headers",
    get: function get() {
      return this[INTERNALS].headers;
    }
  }, {
    key: "redirect",
    get: function get() {
      return this[INTERNALS].redirect;
    }
  }, {
    key: "signal",
    get: function get() {
      return this[INTERNALS].signal;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Request';
    }
  }], [{
    key: "getNodeRequestOptions",
    value: function getNodeRequestOptions(request) {
      var parsedURL = request[INTERNALS].parsedURL;
      var headers = new Headers(request[INTERNALS].headers); // fetch step 1.3

      if (!headers.has('Accept')) headers.set('Accept', '*/*'); // Basic fetch

      if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError('Only absolute URLs are supported');
      if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError('Only HTTP(S) protocols are supported');

      if (request.signal && Minipass.isStream(request.body) && typeof request.body.destroy !== 'function') {
        throw new Error('Cancellation of streamed requests with AbortSignal is not supported');
      } // HTTP-network-or-cache fetch steps 2.4-2.7


      var contentLengthValue = (request.body === null || request.body === undefined) && /^(POST|PUT)$/i.test(request.method) ? '0' : request.body !== null && request.body !== undefined ? getTotalBytes(request) : null;
      if (contentLengthValue) headers.set('Content-Length', contentLengthValue + ''); // HTTP-network-or-cache fetch step 2.11

      if (!headers.has('User-Agent')) headers.set('User-Agent', defaultUserAgent); // HTTP-network-or-cache fetch step 2.15

      if (request.compress && !headers.has('Accept-Encoding')) headers.set('Accept-Encoding', 'gzip,deflate');
      var agent = typeof request.agent === 'function' ? request.agent(parsedURL) : request.agent;
      if (!headers.has('Connection') && !agent) headers.set('Connection', 'close'); // TLS specific options that are handled by node

      var _request$INTERNALS = request[INTERNALS],
          ca = _request$INTERNALS.ca,
          cert = _request$INTERNALS.cert,
          ciphers = _request$INTERNALS.ciphers,
          clientCertEngine = _request$INTERNALS.clientCertEngine,
          crl = _request$INTERNALS.crl,
          dhparam = _request$INTERNALS.dhparam,
          ecdhCurve = _request$INTERNALS.ecdhCurve,
          family = _request$INTERNALS.family,
          honorCipherOrder = _request$INTERNALS.honorCipherOrder,
          key = _request$INTERNALS.key,
          passphrase = _request$INTERNALS.passphrase,
          pfx = _request$INTERNALS.pfx,
          rejectUnauthorized = _request$INTERNALS.rejectUnauthorized,
          secureOptions = _request$INTERNALS.secureOptions,
          secureProtocol = _request$INTERNALS.secureProtocol,
          servername = _request$INTERNALS.servername,
          sessionIdContext = _request$INTERNALS.sessionIdContext; // HTTP-network fetch step 4.2
      // chunked encoding is handled by Node.js

      return _objectSpread({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent: agent,
        ca: ca,
        cert: cert,
        ciphers: ciphers,
        clientCertEngine: clientCertEngine,
        crl: crl,
        dhparam: dhparam,
        ecdhCurve: ecdhCurve,
        family: family,
        honorCipherOrder: honorCipherOrder,
        key: key,
        passphrase: passphrase,
        pfx: pfx,
        rejectUnauthorized: rejectUnauthorized,
        secureOptions: secureOptions,
        secureProtocol: secureProtocol,
        servername: servername,
        sessionIdContext: sessionIdContext
      });
    }
  }]);

  return Request;
}(Body);

module.exports = Request;
Object.defineProperties(Request.prototype, {
  method: {
    enumerable: true
  },
  url: {
    enumerable: true
  },
  headers: {
    enumerable: true
  },
  redirect: {
    enumerable: true
  },
  clone: {
    enumerable: true
  },
  signal: {
    enumerable: true
  }
});