'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var util = require('util');

var crypto = require('crypto');

var fs = require('fs');

var Minipass = require('minipass');

var path = require('path');

var ssri = require('ssri');

var uniqueFilename = require('unique-filename');

var _require = require('./util/disposer'),
    disposer = _require.disposer;

var contentPath = require('./content/path');

var fixOwner = require('./util/fix-owner');

var hashToSegments = require('./util/hash-to-segments');

var indexV = require('../package.json')['cache-version'].index;

var moveFile = require('@npmcli/move-file');

var _rimraf = require('rimraf');

var rimraf = util.promisify(_rimraf);
rimraf.sync = _rimraf.sync;
var appendFile = util.promisify(fs.appendFile);
var readFile = util.promisify(fs.readFile);
var readdir = util.promisify(fs.readdir);
var writeFile = util.promisify(fs.writeFile);

module.exports.NotFoundError =
/*#__PURE__*/
function (_Error) {
  _inherits(NotFoundError, _Error);

  function NotFoundError(cache, key) {
    var _this;

    _classCallCheck(this, NotFoundError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NotFoundError).call(this, "No cache entry for ".concat(key, " found in ").concat(cache)));
    _this.code = 'ENOENT';
    _this.cache = cache;
    _this.key = key;
    return _this;
  }

  return NotFoundError;
}(_wrapNativeSuper(Error));

module.exports.compact = compact;

function compact(cache, key, matchFn) {
  var opts,
      bucket,
      entries,
      newEntries,
      _loop,
      i,
      _ret,
      newIndex,
      setup,
      teardown,
      write,
      _args4 = arguments;

  return regeneratorRuntime.async(function compact$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          opts = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {};
          bucket = bucketPath(cache, key);
          _context4.next = 4;
          return regeneratorRuntime.awrap(bucketEntries(bucket));

        case 4:
          entries = _context4.sent;
          newEntries = []; // we loop backwards because the bottom-most result is the newest
          // since we add new entries with appendFile

          _loop = function _loop(i) {
            var entry = entries[i]; // a null integrity could mean either a delete was appended
            // or the user has simply stored an index that does not map
            // to any content. we determine if the user wants to keep the
            // null integrity based on the validateEntry function passed in options.
            // if the integrity is null and no validateEntry is provided, we break
            // as we consider the null integrity to be a deletion of everything
            // that came before it.

            if (entry.integrity === null && !opts.validateEntry) return "break"; // if this entry is valid, and it is either the first entry or
            // the newEntries array doesn't already include an entry that
            // matches this one based on the provided matchFn, then we add
            // it to the beginning of our list

            if ((!opts.validateEntry || opts.validateEntry(entry) === true) && (newEntries.length === 0 || !newEntries.find(function (oldEntry) {
              return matchFn(oldEntry, entry);
            }))) newEntries.unshift(entry);
          };

          i = entries.length - 1;

        case 8:
          if (!(i >= 0)) {
            _context4.next = 15;
            break;
          }

          _ret = _loop(i);

          if (!(_ret === "break")) {
            _context4.next = 12;
            break;
          }

          return _context4.abrupt("break", 15);

        case 12:
          --i;
          _context4.next = 8;
          break;

        case 15:
          newIndex = '\n' + newEntries.map(function (entry) {
            var stringified = JSON.stringify(entry);
            var hash = hashEntry(stringified);
            return "".concat(hash, "\t").concat(stringified);
          }).join('\n');

          setup = function setup() {
            var target;
            return regeneratorRuntime.async(function setup$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    target = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);
                    _context.next = 3;
                    return regeneratorRuntime.awrap(fixOwner.mkdirfix(cache, path.dirname(target)));

                  case 3:
                    return _context.abrupt("return", {
                      target: target,
                      moved: false
                    });

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            });
          };

          teardown = function teardown(tmp) {
            return regeneratorRuntime.async(function teardown$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (tmp.moved) {
                      _context2.next = 2;
                      break;
                    }

                    return _context2.abrupt("return", rimraf(tmp.target));

                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }
            });
          };

          write = function write(tmp) {
            return regeneratorRuntime.async(function write$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return regeneratorRuntime.awrap(writeFile(tmp.target, newIndex, {
                      flag: 'wx'
                    }));

                  case 2:
                    _context3.next = 4;
                    return regeneratorRuntime.awrap(fixOwner.mkdirfix(cache, path.dirname(bucket)));

                  case 4:
                    _context3.next = 6;
                    return regeneratorRuntime.awrap(moveFile(tmp.target, bucket));

                  case 6:
                    tmp.moved = true;
                    _context3.prev = 7;
                    _context3.next = 10;
                    return regeneratorRuntime.awrap(fixOwner.chownr(cache, bucket));

                  case 10:
                    _context3.next = 16;
                    break;

                  case 12:
                    _context3.prev = 12;
                    _context3.t0 = _context3["catch"](7);

                    if (!(_context3.t0.code !== 'ENOENT')) {
                      _context3.next = 16;
                      break;
                    }

                    throw _context3.t0;

                  case 16:
                  case "end":
                    return _context3.stop();
                }
              }
            }, null, null, [[7, 12]]);
          }; // write the file atomically


          _context4.next = 21;
          return regeneratorRuntime.awrap(disposer(setup(), teardown, write));

        case 21:
          return _context4.abrupt("return", newEntries.reverse().map(function (entry) {
            return formatEntry(cache, entry, true);
          }));

        case 22:
        case "end":
          return _context4.stop();
      }
    }
  });
}

module.exports.insert = insert;

function insert(cache, key, integrity) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var metadata = opts.metadata,
      size = opts.size;
  var bucket = bucketPath(cache, key);
  var entry = {
    key: key,
    integrity: integrity && ssri.stringify(integrity),
    time: Date.now(),
    size: size,
    metadata: metadata
  };
  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(function () {
    var stringified = JSON.stringify(entry); // NOTE - Cleverness ahoy!
    //
    // This works because it's tremendously unlikely for an entry to corrupt
    // another while still preserving the string length of the JSON in
    // question. So, we just slap the length in there and verify it on read.
    //
    // Thanks to @isaacs for the whiteboarding session that ended up with
    // this.

    return appendFile(bucket, "\n".concat(hashEntry(stringified), "\t").concat(stringified));
  }).then(function () {
    return fixOwner.chownr(cache, bucket);
  })["catch"](function (err) {
    if (err.code === 'ENOENT') return undefined;
    throw err; // There's a class of race conditions that happen when things get deleted
    // during fixOwner, or between the two mkdirfix/chownr calls.
    //
    // It's perfectly fine to just not bother in those cases and lie
    // that the index entry was written. Because it's a cache.
  }).then(function () {
    return formatEntry(cache, entry);
  });
}

module.exports.insert.sync = insertSync;

function insertSync(cache, key, integrity) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var metadata = opts.metadata,
      size = opts.size;
  var bucket = bucketPath(cache, key);
  var entry = {
    key: key,
    integrity: integrity && ssri.stringify(integrity),
    time: Date.now(),
    size: size,
    metadata: metadata
  };
  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));
  var stringified = JSON.stringify(entry);
  fs.appendFileSync(bucket, "\n".concat(hashEntry(stringified), "\t").concat(stringified));

  try {
    fixOwner.chownr.sync(cache, bucket);
  } catch (err) {
    if (err.code !== 'ENOENT') throw err;
  }

  return formatEntry(cache, entry);
}

module.exports.find = find;

function find(cache, key) {
  var bucket = bucketPath(cache, key);
  return bucketEntries(bucket).then(function (entries) {
    return entries.reduce(function (latest, next) {
      if (next && next.key === key) return formatEntry(cache, next);else return latest;
    }, null);
  })["catch"](function (err) {
    if (err.code === 'ENOENT') return null;else throw err;
  });
}

module.exports.find.sync = findSync;

function findSync(cache, key) {
  var bucket = bucketPath(cache, key);

  try {
    return bucketEntriesSync(bucket).reduce(function (latest, next) {
      if (next && next.key === key) return formatEntry(cache, next);else return latest;
    }, null);
  } catch (err) {
    if (err.code === 'ENOENT') return null;else throw err;
  }
}

module.exports["delete"] = del;

function del(cache, key) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (!opts.removeFully) return insert(cache, key, null, opts);
  var bucket = bucketPath(cache, key);
  return rimraf(bucket);
}

module.exports["delete"].sync = delSync;

function delSync(cache, key) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (!opts.removeFully) return insertSync(cache, key, null, opts);
  var bucket = bucketPath(cache, key);
  return rimraf.sync(bucket);
}

module.exports.lsStream = lsStream;

function lsStream(cache) {
  var indexDir = bucketDir(cache);
  var stream = new Minipass({
    objectMode: true
  });
  readdirOrEmpty(indexDir).then(function (buckets) {
    return Promise.all(buckets.map(function (bucket) {
      var bucketPath = path.join(indexDir, bucket);
      return readdirOrEmpty(bucketPath).then(function (subbuckets) {
        return Promise.all(subbuckets.map(function (subbucket) {
          var subbucketPath = path.join(bucketPath, subbucket); // "/cachename/<bucket 0xFF>/<bucket 0xFF>./*"

          return readdirOrEmpty(subbucketPath).then(function (entries) {
            return Promise.all(entries.map(function (entry) {
              var entryPath = path.join(subbucketPath, entry);
              return bucketEntries(entryPath).then(function (entries) {
                return (// using a Map here prevents duplicate keys from
                  // showing up twice, I guess?
                  entries.reduce(function (acc, entry) {
                    acc.set(entry.key, entry);
                    return acc;
                  }, new Map())
                );
              }).then(function (reduced) {
                // reduced is a map of key => entry
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = reduced.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _entry = _step.value;
                    var formatted = formatEntry(cache, _entry);
                    if (formatted) stream.write(formatted);
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
              })["catch"](function (err) {
                if (err.code === 'ENOENT') return undefined;
                throw err;
              });
            }));
          });
        }));
      });
    }));
  }).then(function () {
    return stream.end();
  }, function (err) {
    return stream.emit('error', err);
  });
  return stream;
}

module.exports.ls = ls;

function ls(cache) {
  return lsStream(cache).collect().then(function (entries) {
    return entries.reduce(function (acc, xs) {
      acc[xs.key] = xs;
      return acc;
    }, {});
  });
}

module.exports.bucketEntries = bucketEntries;

function bucketEntries(bucket, filter) {
  return readFile(bucket, 'utf8').then(function (data) {
    return _bucketEntries(data, filter);
  });
}

module.exports.bucketEntries.sync = bucketEntriesSync;

function bucketEntriesSync(bucket, filter) {
  var data = fs.readFileSync(bucket, 'utf8');
  return _bucketEntries(data, filter);
}

function _bucketEntries(data, filter) {
  var entries = [];
  data.split('\n').forEach(function (entry) {
    if (!entry) return;
    var pieces = entry.split('\t');

    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {
      // Hash is no good! Corruption or malice? Doesn't matter!
      // EJECT EJECT
      return;
    }

    var obj;

    try {
      obj = JSON.parse(pieces[1]);
    } catch (e) {
      // Entry is corrupted!
      return;
    }

    if (obj) entries.push(obj);
  });
  return entries;
}

module.exports.bucketDir = bucketDir;

function bucketDir(cache) {
  return path.join(cache, "index-v".concat(indexV));
}

module.exports.bucketPath = bucketPath;

function bucketPath(cache, key) {
  var hashed = hashKey(key);
  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));
}

module.exports.hashKey = hashKey;

function hashKey(key) {
  return hash(key, 'sha256');
}

module.exports.hashEntry = hashEntry;

function hashEntry(str) {
  return hash(str, 'sha1');
}

function hash(str, digest) {
  return crypto.createHash(digest).update(str).digest('hex');
}

function formatEntry(cache, entry, keepAll) {
  // Treat null digests as deletions. They'll shadow any previous entries.
  if (!entry.integrity && !keepAll) return null;
  return {
    key: entry.key,
    integrity: entry.integrity,
    path: entry.integrity ? contentPath(cache, entry.integrity) : undefined,
    size: entry.size,
    time: entry.time,
    metadata: entry.metadata
  };
}

function readdirOrEmpty(dir) {
  return readdir(dir)["catch"](function (err) {
    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return [];
    throw err;
  });
}