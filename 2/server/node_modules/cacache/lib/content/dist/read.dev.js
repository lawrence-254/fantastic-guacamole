'use strict';

var util = require('util');

var fs = require('fs');

var fsm = require('fs-minipass');

var ssri = require('ssri');

var contentPath = require('./path');

var Pipeline = require('minipass-pipeline');

var lstat = util.promisify(fs.lstat);
var readFile = util.promisify(fs.readFile);
module.exports = read;
var MAX_SINGLE_READ_SIZE = 64 * 1024 * 1024;

function read(cache, integrity) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var size = opts.size;
  return withContentSri(cache, integrity, function (cpath, sri) {
    // get size
    return lstat(cpath).then(function (stat) {
      return {
        stat: stat,
        cpath: cpath,
        sri: sri
      };
    });
  }).then(function (_ref) {
    var stat = _ref.stat,
        cpath = _ref.cpath,
        sri = _ref.sri;
    if (typeof size === 'number' && stat.size !== size) throw sizeError(size, stat.size);
    if (stat.size > MAX_SINGLE_READ_SIZE) return readPipeline(cpath, stat.size, sri, new Pipeline()).concat();
    return readFile(cpath, null).then(function (data) {
      if (!ssri.checkData(data, sri)) throw integrityError(sri, cpath);
      return data;
    });
  });
}

var readPipeline = function readPipeline(cpath, size, sri, stream) {
  stream.push(new fsm.ReadStream(cpath, {
    size: size,
    readSize: MAX_SINGLE_READ_SIZE
  }), ssri.integrityStream({
    integrity: sri,
    size: size
  }));
  return stream;
};

module.exports.sync = readSync;

function readSync(cache, integrity) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var size = opts.size;
  return withContentSriSync(cache, integrity, function (cpath, sri) {
    var data = fs.readFileSync(cpath);
    if (typeof size === 'number' && size !== data.length) throw sizeError(size, data.length);
    if (ssri.checkData(data, sri)) return data;
    throw integrityError(sri, cpath);
  });
}

module.exports.stream = readStream;
module.exports.readStream = readStream;

function readStream(cache, integrity) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var size = opts.size;
  var stream = new Pipeline();
  withContentSri(cache, integrity, function (cpath, sri) {
    // just lstat to ensure it exists
    return lstat(cpath).then(function (stat) {
      return {
        stat: stat,
        cpath: cpath,
        sri: sri
      };
    });
  }).then(function (_ref2) {
    var stat = _ref2.stat,
        cpath = _ref2.cpath,
        sri = _ref2.sri;
    if (typeof size === 'number' && size !== stat.size) return stream.emit('error', sizeError(size, stat.size));
    readPipeline(cpath, stat.size, sri, stream);
  }, function (er) {
    return stream.emit('error', er);
  });
  return stream;
}

var copyFile;

if (fs.copyFile) {
  module.exports.copy = copy;
  module.exports.copy.sync = copySync;
  copyFile = util.promisify(fs.copyFile);
}

function copy(cache, integrity, dest) {
  return withContentSri(cache, integrity, function (cpath, sri) {
    return copyFile(cpath, dest);
  });
}

function copySync(cache, integrity, dest) {
  return withContentSriSync(cache, integrity, function (cpath, sri) {
    return fs.copyFileSync(cpath, dest);
  });
}

module.exports.hasContent = hasContent;

function hasContent(cache, integrity) {
  if (!integrity) return Promise.resolve(false);
  return withContentSri(cache, integrity, function (cpath, sri) {
    return lstat(cpath).then(function (stat) {
      return {
        size: stat.size,
        sri: sri,
        stat: stat
      };
    });
  })["catch"](function (err) {
    if (err.code === 'ENOENT') return false;

    if (err.code === 'EPERM') {
      /* istanbul ignore else */
      if (process.platform !== 'win32') throw err;else return false;
    }
  });
}

module.exports.hasContent.sync = hasContentSync;

function hasContentSync(cache, integrity) {
  if (!integrity) return false;
  return withContentSriSync(cache, integrity, function (cpath, sri) {
    try {
      var stat = fs.lstatSync(cpath);
      return {
        size: stat.size,
        sri: sri,
        stat: stat
      };
    } catch (err) {
      if (err.code === 'ENOENT') return false;

      if (err.code === 'EPERM') {
        /* istanbul ignore else */
        if (process.platform !== 'win32') throw err;else return false;
      }
    }
  });
}

function withContentSri(cache, integrity, fn) {
  var tryFn = function tryFn() {
    var sri = ssri.parse(integrity); // If `integrity` has multiple entries, pick the first digest
    // with available local data.

    var algo = sri.pickAlgorithm();
    var digests = sri[algo];

    if (digests.length <= 1) {
      var cpath = contentPath(cache, digests[0]);
      return fn(cpath, digests[0]);
    } else {
      // Can't use race here because a generic error can happen before
      // a ENOENT error, and can happen before a valid result
      return Promise.all(digests.map(function (meta) {
        return withContentSri(cache, meta, fn)["catch"](function (err) {
          if (err.code === 'ENOENT') {
            return Object.assign(new Error('No matching content found for ' + sri.toString()), {
              code: 'ENOENT'
            });
          }

          return err;
        });
      })).then(function (results) {
        // Return the first non error if it is found
        var result = results.find(function (r) {
          return !(r instanceof Error);
        });
        if (result) return result; // Throw the No matching content found error

        var enoentError = results.find(function (r) {
          return r.code === 'ENOENT';
        });
        if (enoentError) throw enoentError; // Throw generic error

        throw results.find(function (r) {
          return r instanceof Error;
        });
      });
    }
  };

  return new Promise(function (resolve, reject) {
    try {
      tryFn().then(resolve)["catch"](reject);
    } catch (err) {
      reject(err);
    }
  });
}

function withContentSriSync(cache, integrity, fn) {
  var sri = ssri.parse(integrity); // If `integrity` has multiple entries, pick the first digest
  // with available local data.

  var algo = sri.pickAlgorithm();
  var digests = sri[algo];

  if (digests.length <= 1) {
    var cpath = contentPath(cache, digests[0]);
    return fn(cpath, digests[0]);
  } else {
    var lastErr = null;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = digests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var meta = _step.value;

        try {
          return withContentSriSync(cache, meta, fn);
        } catch (err) {
          lastErr = err;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    throw lastErr;
  }
}

function sizeError(expected, found) {
  var err = new Error("Bad data size: expected inserted data to be ".concat(expected, " bytes, but got ").concat(found, " instead"));
  err.expected = expected;
  err.found = found;
  err.code = 'EBADSIZE';
  return err;
}

function integrityError(sri, path) {
  var err = new Error("Integrity verification failed for ".concat(sri, " (").concat(path, ")"));
  err.code = 'EINTEGRITY';
  err.sri = sri;
  err.path = path;
  return err;
}