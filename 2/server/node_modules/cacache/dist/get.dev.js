'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Collect = require('minipass-collect');

var Minipass = require('minipass');

var Pipeline = require('minipass-pipeline');

var fs = require('fs');

var util = require('util');

var index = require('./lib/entry-index');

var memo = require('./lib/memoization');

var read = require('./lib/content/read');

var writeFile = util.promisify(fs.writeFile);

function getData(cache, key) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var integrity = opts.integrity,
      memoize = opts.memoize,
      size = opts.size;
  var memoized = memo.get(cache, key, opts);

  if (memoized && memoize !== false) {
    return Promise.resolve({
      metadata: memoized.entry.metadata,
      data: memoized.data,
      integrity: memoized.entry.integrity,
      size: memoized.entry.size
    });
  }

  return index.find(cache, key, opts).then(function (entry) {
    if (!entry) throw new index.NotFoundError(cache, key);
    return read(cache, entry.integrity, {
      integrity: integrity,
      size: size
    }).then(function (data) {
      if (memoize) memo.put(cache, entry, data, opts);
      return {
        data: data,
        metadata: entry.metadata,
        size: entry.size,
        integrity: entry.integrity
      };
    });
  });
}

module.exports = getData;

function getDataByDigest(cache, key) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var integrity = opts.integrity,
      memoize = opts.memoize,
      size = opts.size;
  var memoized = memo.get.byDigest(cache, key, opts);
  if (memoized && memoize !== false) return Promise.resolve(memoized);
  return read(cache, key, {
    integrity: integrity,
    size: size
  }).then(function (res) {
    if (memoize) memo.put.byDigest(cache, key, res, opts);
    return res;
  });
}

module.exports.byDigest = getDataByDigest;

function getDataSync(cache, key) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var integrity = opts.integrity,
      memoize = opts.memoize,
      size = opts.size;
  var memoized = memo.get(cache, key, opts);

  if (memoized && memoize !== false) {
    return {
      metadata: memoized.entry.metadata,
      data: memoized.data,
      integrity: memoized.entry.integrity,
      size: memoized.entry.size
    };
  }

  var entry = index.find.sync(cache, key, opts);
  if (!entry) throw new index.NotFoundError(cache, key);
  var data = read.sync(cache, entry.integrity, {
    integrity: integrity,
    size: size
  });
  var res = {
    metadata: entry.metadata,
    data: data,
    size: entry.size,
    integrity: entry.integrity
  };
  if (memoize) memo.put(cache, entry, res.data, opts);
  return res;
}

module.exports.sync = getDataSync;

function getDataByDigestSync(cache, digest) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var integrity = opts.integrity,
      memoize = opts.memoize,
      size = opts.size;
  var memoized = memo.get.byDigest(cache, digest, opts);
  if (memoized && memoize !== false) return memoized;
  var res = read.sync(cache, digest, {
    integrity: integrity,
    size: size
  });
  if (memoize) memo.put.byDigest(cache, digest, res, opts);
  return res;
}

module.exports.sync.byDigest = getDataByDigestSync;

var getMemoizedStream = function getMemoizedStream(memoized) {
  var stream = new Minipass();
  stream.on('newListener', function (ev, cb) {
    ev === 'metadata' && cb(memoized.entry.metadata);
    ev === 'integrity' && cb(memoized.entry.integrity);
    ev === 'size' && cb(memoized.entry.size);
  });
  stream.end(memoized.data);
  return stream;
};

function getStream(cache, key) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var memoize = opts.memoize,
      size = opts.size;
  var memoized = memo.get(cache, key, opts);
  if (memoized && memoize !== false) return getMemoizedStream(memoized);
  var stream = new Pipeline();
  index.find(cache, key).then(function (entry) {
    if (!entry) throw new index.NotFoundError(cache, key);
    stream.emit('metadata', entry.metadata);
    stream.emit('integrity', entry.integrity);
    stream.emit('size', entry.size);
    stream.on('newListener', function (ev, cb) {
      ev === 'metadata' && cb(entry.metadata);
      ev === 'integrity' && cb(entry.integrity);
      ev === 'size' && cb(entry.size);
    });
    var src = read.readStream(cache, entry.integrity, _objectSpread({}, opts, {
      size: typeof size !== 'number' ? entry.size : size
    }));

    if (memoize) {
      var memoStream = new Collect.PassThrough();
      memoStream.on('collect', function (data) {
        return memo.put(cache, entry, data, opts);
      });
      stream.unshift(memoStream);
    }

    stream.unshift(src);
  })["catch"](function (err) {
    return stream.emit('error', err);
  });
  return stream;
}

module.exports.stream = getStream;

function getStreamDigest(cache, integrity) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var memoize = opts.memoize;
  var memoized = memo.get.byDigest(cache, integrity, opts);

  if (memoized && memoize !== false) {
    var stream = new Minipass();
    stream.end(memoized);
    return stream;
  } else {
    var _stream = read.readStream(cache, integrity, opts);

    if (!memoize) return _stream;
    var memoStream = new Collect.PassThrough();
    memoStream.on('collect', function (data) {
      return memo.put.byDigest(cache, integrity, data, opts);
    });
    return new Pipeline(_stream, memoStream);
  }
}

module.exports.stream.byDigest = getStreamDigest;

function info(cache, key) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var memoize = opts.memoize;
  var memoized = memo.get(cache, key, opts);
  if (memoized && memoize !== false) return Promise.resolve(memoized.entry);else return index.find(cache, key);
}

module.exports.info = info;

function copy(cache, key, dest) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (read.copy) {
    return index.find(cache, key, opts).then(function (entry) {
      if (!entry) throw new index.NotFoundError(cache, key);
      return read.copy(cache, entry.integrity, dest, opts).then(function () {
        return {
          metadata: entry.metadata,
          size: entry.size,
          integrity: entry.integrity
        };
      });
    });
  }

  return getData(cache, key, opts).then(function (res) {
    return writeFile(dest, res.data).then(function () {
      return {
        metadata: res.metadata,
        size: res.size,
        integrity: res.integrity
      };
    });
  });
}

module.exports.copy = copy;

function copyByDigest(cache, key, dest) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (read.copy) return read.copy(cache, key, dest, opts).then(function () {
    return key;
  });
  return getDataByDigest(cache, key, opts).then(function (res) {
    return writeFile(dest, res).then(function () {
      return key;
    });
  });
}

module.exports.copy.byDigest = copyByDigest;
module.exports.hasContent = read.hasContent;