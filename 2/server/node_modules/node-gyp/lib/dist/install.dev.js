'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var fs = require('graceful-fs');

var os = require('os');

var tar = require('tar');

var path = require('path');

var util = require('util');

var stream = require('stream');

var crypto = require('crypto');

var log = require('npmlog');

var semver = require('semver');

var fetch = require('make-fetch-happen');

var processRelease = require('./process-release');

var win = process.platform === 'win32';
var streamPipeline = util.promisify(stream.pipeline);
/**
 * @param {typeof import('graceful-fs')} fs
 */

function install(fs, gyp, argv) {
  var release, devDir, installVersionFile, installVersion, ver, go, valid, rollback, eaccesFallback;
  return regeneratorRuntime.async(function install$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          eaccesFallback = function _ref7(err) {
            var noretry, tmpdir, userString;
            return regeneratorRuntime.async(function eaccesFallback$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    noretry = '--node_gyp_internal_noretry';

                    if (!(argv.indexOf(noretry) !== -1)) {
                      _context5.next = 3;
                      break;
                    }

                    throw err;

                  case 3:
                    tmpdir = os.tmpdir();
                    gyp.devDir = path.resolve(tmpdir, '.node-gyp');
                    userString = '';

                    try {
                      // os.userInfo can fail on some systems, it's not critical here
                      userString = " (\"".concat(os.userInfo().username, "\")");
                    } catch (e) {}

                    log.warn('EACCES', 'current user%s does not have permission to access the dev dir "%s"', userString, devDir);
                    log.warn('EACCES', 'attempting to reinstall using temporary dev dir "%s"', gyp.devDir);

                    if (process.cwd() === tmpdir) {
                      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');
                      gyp.todo.push({
                        name: 'remove',
                        args: argv
                      });
                    }

                    return _context5.abrupt("return", util.promisify(gyp.commands.install)([noretry].concat(argv)));

                  case 11:
                  case "end":
                    return _context5.stop();
                }
              }
            });
          };

          rollback = function _ref6(err) {
            return regeneratorRuntime.async(function rollback$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong

                    _context4.next = 3;
                    return regeneratorRuntime.awrap(util.promisify(gyp.commands.remove)([release.versionDir]));

                  case 3:
                    throw err;

                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            });
          };

          valid = function _ref5(file) {
            // header files
            var extname = path.extname(file);
            return extname === '.h' || extname === '.gypi';
          };

          go = function _ref4() {
            var created, tarPath, extractCount, contentShasums, expectShasums, isValid, res, installVersionPath, k, downloadShasums, downloadNodeLib;
            return regeneratorRuntime.async(function go$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    downloadNodeLib = function _ref3() {
                      log.verbose('on Windows; need to download `' + release.name + '.lib`...');
                      var archs = ['ia32', 'x64', 'arm64'];
                      return archs.map(function _callee(arch) {
                        var dir, targetLibPath, _release$arch, libUrl, libPath, name, res;

                        return regeneratorRuntime.async(function _callee$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                dir = path.resolve(devDir, arch);
                                targetLibPath = path.resolve(dir, release.name + '.lib');
                                _release$arch = release[arch], libUrl = _release$arch.libUrl, libPath = _release$arch.libPath;
                                name = "".concat(arch, " ").concat(release.name, ".lib");
                                log.verbose(name, 'dir', dir);
                                log.verbose(name, 'url', libUrl);
                                _context2.next = 8;
                                return regeneratorRuntime.awrap(fs.promises.mkdir(dir, {
                                  recursive: true
                                }));

                              case 8:
                                log.verbose('streaming', name, 'to:', targetLibPath);
                                _context2.next = 11;
                                return regeneratorRuntime.awrap(download(gyp, libUrl));

                              case 11:
                                res = _context2.sent;

                                if (!(res.status === 403 || res.status === 404)) {
                                  _context2.next = 17;
                                  break;
                                }

                                if (arch === 'arm64') {
                                  // Arm64 is a newer platform on Windows and not all node distributions provide it.
                                  log.verbose("".concat(name, " was not found in ").concat(libUrl));
                                } else {
                                  log.warn("".concat(name, " was not found in ").concat(libUrl));
                                }

                                return _context2.abrupt("return");

                              case 17:
                                if (!(res.status !== 200)) {
                                  _context2.next = 19;
                                  break;
                                }

                                throw new Error("".concat(res.status, " status code downloading ").concat(name));

                              case 19:
                                return _context2.abrupt("return", streamPipeline(res.body, new ShaSum(function (_, checksum) {
                                  contentShasums[libPath] = checksum;
                                  log.verbose('content checksum', libPath, checksum);
                                }), fs.createWriteStream(targetLibPath)));

                              case 20:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        });
                      });
                    };

                    downloadShasums = function _ref2() {
                      var res, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, items, name;

                      return regeneratorRuntime.async(function downloadShasums$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');
                              log.verbose('checksum url', release.shasumsUrl);
                              _context.next = 4;
                              return regeneratorRuntime.awrap(download(gyp, release.shasumsUrl));

                            case 4:
                              res = _context.sent;

                              if (!(res.status !== 200)) {
                                _context.next = 7;
                                break;
                              }

                              throw new Error("".concat(res.status, "  status code downloading checksum"));

                            case 7:
                              _iteratorNormalCompletion = true;
                              _didIteratorError = false;
                              _iteratorError = undefined;
                              _context.prev = 10;
                              _context.next = 13;
                              return regeneratorRuntime.awrap(res.text());

                            case 13:
                              _context.t0 = Symbol.iterator;
                              _iterator = _context.sent.trim().split('\n')[_context.t0]();

                            case 15:
                              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                _context.next = 25;
                                break;
                              }

                              line = _step.value;
                              items = line.trim().split(/\s+/);

                              if (!(items.length !== 2)) {
                                _context.next = 20;
                                break;
                              }

                              return _context.abrupt("return");

                            case 20:
                              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz
                              name = items[1].replace(/^\.\//, '');
                              expectShasums[name] = items[0];

                            case 22:
                              _iteratorNormalCompletion = true;
                              _context.next = 15;
                              break;

                            case 25:
                              _context.next = 31;
                              break;

                            case 27:
                              _context.prev = 27;
                              _context.t1 = _context["catch"](10);
                              _didIteratorError = true;
                              _iteratorError = _context.t1;

                            case 31:
                              _context.prev = 31;
                              _context.prev = 32;

                              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                                _iterator["return"]();
                              }

                            case 34:
                              _context.prev = 34;

                              if (!_didIteratorError) {
                                _context.next = 37;
                                break;
                              }

                              throw _iteratorError;

                            case 37:
                              return _context.finish(34);

                            case 38:
                              return _context.finish(31);

                            case 39:
                              log.verbose('checksum data', JSON.stringify(expectShasums));

                            case 40:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, null, null, [[10, 27, 31, 39], [32,, 34, 38]]);
                    };

                    isValid = function _ref(path) {
                      var isValid = valid(path);

                      if (isValid) {
                        log.verbose('extracted file from tarball', path);
                        extractCount++;
                      } else {
                        // invalid
                        log.silly('ignoring from tarball', path);
                      }

                      return isValid;
                    };

                    log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files

                    _context3.prev = 4;
                    _context3.next = 7;
                    return regeneratorRuntime.awrap(fs.promises.mkdir(devDir, {
                      recursive: true
                    }));

                  case 7:
                    created = _context3.sent;

                    if (created) {
                      log.verbose('created nodedir', created);
                    }

                    _context3.next = 16;
                    break;

                  case 11:
                    _context3.prev = 11;
                    _context3.t0 = _context3["catch"](4);

                    if (!(_context3.t0.code === 'EACCES')) {
                      _context3.next = 15;
                      break;
                    }

                    return _context3.abrupt("return", eaccesFallback(_context3.t0));

                  case 15:
                    throw _context3.t0;

                  case 16:
                    // now download the node tarball
                    tarPath = gyp.opts.tarball;
                    extractCount = 0;
                    contentShasums = {};
                    expectShasums = {}; // checks if a file to be extracted from the tarball is valid.
                    // only .h header files and the gyp files get extracted

                    if (!tarPath) {
                      _context3.next = 25;
                      break;
                    }

                    _context3.next = 23;
                    return regeneratorRuntime.awrap(tar.extract({
                      file: tarPath,
                      strip: 1,
                      filter: isValid,
                      cwd: devDir
                    }));

                  case 23:
                    _context3.next = 40;
                    break;

                  case 25:
                    _context3.prev = 25;
                    _context3.next = 28;
                    return regeneratorRuntime.awrap(download(gyp, release.tarballUrl));

                  case 28:
                    res = _context3.sent;

                    if (!(res.status !== 200)) {
                      _context3.next = 31;
                      break;
                    }

                    throw new Error("".concat(res.status, " response downloading ").concat(release.tarballUrl));

                  case 31:
                    _context3.next = 33;
                    return regeneratorRuntime.awrap(streamPipeline(res.body, // content checksum
                    new ShaSum(function (_, checksum) {
                      var filename = path.basename(release.tarballUrl).trim();
                      contentShasums[filename] = checksum;
                      log.verbose('content checksum', filename, checksum);
                    }), tar.extract({
                      strip: 1,
                      cwd: devDir,
                      filter: isValid
                    })));

                  case 33:
                    _context3.next = 40;
                    break;

                  case 35:
                    _context3.prev = 35;
                    _context3.t1 = _context3["catch"](25);

                    if (!(_context3.t1.code === 'ENOTFOUND')) {
                      _context3.next = 39;
                      break;
                    }

                    throw new Error('This is most likely not a problem with node-gyp or the package itself and\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \n' + 'network settings.');

                  case 39:
                    throw _context3.t1;

                  case 40:
                    if (!(extractCount === 0)) {
                      _context3.next = 42;
                      break;
                    }

                    throw new Error('There was a fatal problem while downloading/extracting the tarball');

                  case 42:
                    log.verbose('tarball', 'done parsing tarball');
                    installVersionPath = path.resolve(devDir, 'installVersion');
                    _context3.next = 46;
                    return regeneratorRuntime.awrap(Promise.all([].concat(_toConsumableArray(win ? downloadNodeLib() : []), [// write the "installVersion" file
                    fs.promises.writeFile(installVersionPath, gyp["package"].installVersion + '\n')], _toConsumableArray(!tarPath || win ? [downloadShasums()] : []))));

                  case 46:
                    log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums

                    _context3.t2 = regeneratorRuntime.keys(contentShasums);

                  case 48:
                    if ((_context3.t3 = _context3.t2()).done) {
                      _context3.next = 55;
                      break;
                    }

                    k = _context3.t3.value;
                    log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);

                    if (!(contentShasums[k] !== expectShasums[k])) {
                      _context3.next = 53;
                      break;
                    }

                    throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);

                  case 53:
                    _context3.next = 48;
                    break;

                  case 55:
                  case "end":
                    return _context3.stop();
                }
              }
            }, null, null, [[4, 11], [25, 35]]);
          };

          release = processRelease(argv, gyp, process.version, process.release); // Determine which node dev files version we are installing

          log.verbose('install', 'input version string %j', release.version);

          if (release.semver) {
            _context6.next = 8;
            break;
          }

          throw new Error('Invalid version number: ' + release.version);

        case 8:
          if (!semver.lt(release.version, '0.8.0')) {
            _context6.next = 10;
            break;
          }

          throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);

        case 10:
          if (!(release.semver.prerelease[0] === 'pre')) {
            _context6.next = 16;
            break;
          }

          log.verbose('detected "pre" node version', release.version);

          if (gyp.opts.nodedir) {
            _context6.next = 14;
            break;
          }

          throw new Error('"pre" versions of node cannot be installed, use the --nodedir flag instead');

        case 14:
          log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);
          return _context6.abrupt("return");

        case 16:
          // flatten version into String
          log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed

          devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;
          // check if it is already installed, and only install when needed

          if (!gyp.opts.ensure) {
            _context6.next = 73;
            break;
          }

          log.verbose('install', '--ensure was passed, so won\'t reinstall if already installed');
          _context6.prev = 20;
          _context6.next = 23;
          return regeneratorRuntime.awrap(fs.promises.stat(devDir));

        case 23:
          _context6.next = 43;
          break;

        case 25:
          _context6.prev = 25;
          _context6.t0 = _context6["catch"](20);

          if (!(_context6.t0.code === 'ENOENT')) {
            _context6.next = 40;
            break;
          }

          log.verbose('install', 'version not already installed, continuing with install', release.version);
          _context6.prev = 29;
          _context6.next = 32;
          return regeneratorRuntime.awrap(go());

        case 32:
          return _context6.abrupt("return", _context6.sent);

        case 35:
          _context6.prev = 35;
          _context6.t1 = _context6["catch"](29);
          return _context6.abrupt("return", rollback(_context6.t1));

        case 38:
          _context6.next = 42;
          break;

        case 40:
          if (!(_context6.t0.code === 'EACCES')) {
            _context6.next = 42;
            break;
          }

          return _context6.abrupt("return", eaccesFallback(_context6.t0));

        case 42:
          throw _context6.t0;

        case 43:
          log.verbose('install', 'version is already installed, need to check "installVersion"');
          installVersionFile = path.resolve(devDir, 'installVersion');
          installVersion = 0;
          _context6.prev = 46;
          _context6.next = 49;
          return regeneratorRuntime.awrap(fs.promises.readFile(installVersionFile, 'ascii'));

        case 49:
          ver = _context6.sent;
          installVersion = parseInt(ver, 10) || 0;
          _context6.next = 57;
          break;

        case 53:
          _context6.prev = 53;
          _context6.t2 = _context6["catch"](46);

          if (!(_context6.t2.code !== 'ENOENT')) {
            _context6.next = 57;
            break;
          }

          throw _context6.t2;

        case 57:
          log.verbose('got "installVersion"', installVersion);
          log.verbose('needs "installVersion"', gyp["package"].installVersion);

          if (!(installVersion < gyp["package"].installVersion)) {
            _context6.next = 70;
            break;
          }

          log.verbose('install', 'version is no good; reinstalling');
          _context6.prev = 61;
          _context6.next = 64;
          return regeneratorRuntime.awrap(go());

        case 64:
          return _context6.abrupt("return", _context6.sent);

        case 67:
          _context6.prev = 67;
          _context6.t3 = _context6["catch"](61);
          return _context6.abrupt("return", rollback(_context6.t3));

        case 70:
          log.verbose('install', 'version is good');
          _context6.next = 82;
          break;

        case 73:
          _context6.prev = 73;
          _context6.next = 76;
          return regeneratorRuntime.awrap(go());

        case 76:
          return _context6.abrupt("return", _context6.sent);

        case 79:
          _context6.prev = 79;
          _context6.t4 = _context6["catch"](73);
          return _context6.abrupt("return", rollback(_context6.t4));

        case 82:
        case "end":
          return _context6.stop();
      }
    }
  }, null, null, [[20, 25], [29, 35], [46, 53], [61, 67], [73, 79]]);
}

var ShaSum =
/*#__PURE__*/
function (_stream$Transform) {
  _inherits(ShaSum, _stream$Transform);

  function ShaSum(callback) {
    var _this;

    _classCallCheck(this, ShaSum);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ShaSum).call(this));
    _this._callback = callback;
    _this._digester = crypto.createHash('sha256');
    return _this;
  }

  _createClass(ShaSum, [{
    key: "_transform",
    value: function _transform(chunk, _, callback) {
      this._digester.update(chunk);

      callback(null, chunk);
    }
  }, {
    key: "_flush",
    value: function _flush(callback) {
      this._callback(null, this._digester.digest('hex'));

      callback();
    }
  }]);

  return ShaSum;
}(stream.Transform);

function download(gyp, url) {
  var requestOpts, cafile, res;
  return regeneratorRuntime.async(function download$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          log.http('GET', url);
          requestOpts = {
            headers: {
              'User-Agent': "node-gyp v".concat(gyp.version, " (node ").concat(process.version, ")"),
              Connection: 'keep-alive'
            },
            proxy: gyp.opts.proxy,
            noProxy: gyp.opts.noproxy
          };
          cafile = gyp.opts.cafile;

          if (!cafile) {
            _context7.next = 7;
            break;
          }

          _context7.next = 6;
          return regeneratorRuntime.awrap(readCAFile(cafile));

        case 6:
          requestOpts.ca = _context7.sent;

        case 7:
          _context7.next = 9;
          return regeneratorRuntime.awrap(fetch(url, requestOpts));

        case 9:
          res = _context7.sent;
          log.http(res.status, res.url);
          return _context7.abrupt("return", res);

        case 12:
        case "end":
          return _context7.stop();
      }
    }
  });
}

function readCAFile(filename) {
  var ca, re;
  return regeneratorRuntime.async(function readCAFile$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return regeneratorRuntime.awrap(fs.promises.readFile(filename, 'utf8'));

        case 2:
          ca = _context8.sent;
          re = /(-----BEGIN CERTIFICATE-----[\S\s]*?-----END CERTIFICATE-----)/g;
          return _context8.abrupt("return", ca.match(re));

        case 5:
        case "end":
          return _context8.stop();
      }
    }
  });
}

module.exports = function (gyp, argv, callback) {
  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);
};

module.exports.test = {
  download: download,
  install: install,
  readCAFile: readCAFile
};
module.exports.usage = 'Install node development files for the specified node version.';