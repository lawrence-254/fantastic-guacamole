'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require('tap'),
    test = _require.test;

var fs = require('fs');

var path = require('path');

var util = require('util');

var http = require('http');

var https = require('https');

var install = require('../lib/install');

var semver = require('semver');

var devDir = require('./common').devDir();

var rimraf = require('rimraf');

var gyp = require('../lib/node-gyp');

var log = require('npmlog');

log.level = 'warn';
test('download over http', function _callee(t) {
  var server, host, _server$address, port, gyp, url, res;

  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          t.plan(2);
          server = http.createServer(function (req, res) {
            t.strictEqual(req.headers['user-agent'], "node-gyp v42 (node ".concat(process.version, ")"));
            res.end('ok');
          });
          t.tearDown(function () {
            return new Promise(function (resolve) {
              return server.close(resolve);
            });
          });
          host = 'localhost';
          _context.next = 6;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return server.listen(0, host, resolve);
          }));

        case 6:
          _server$address = server.address(), port = _server$address.port;
          gyp = {
            opts: {},
            version: '42'
          };
          url = "http://".concat(host, ":").concat(port);
          _context.next = 11;
          return regeneratorRuntime.awrap(install.test.download(gyp, url));

        case 11:
          res = _context.sent;
          _context.t0 = t;
          _context.next = 15;
          return regeneratorRuntime.awrap(res.text());

        case 15:
          _context.t1 = _context.sent;

          _context.t0.strictEqual.call(_context.t0, _context.t1, 'ok');

        case 17:
        case "end":
          return _context.stop();
      }
    }
  });
});
test('download over https with custom ca', function _callee2(t) {
  var cafile, _ref, _ref2, cert, key, ca, options, server, host, _server$address2, port, gyp, url, res;

  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          t.plan(3);
          cafile = path.join(__dirname, '/fixtures/ca.crt');
          _context2.next = 4;
          return regeneratorRuntime.awrap(Promise.all([fs.promises.readFile(path.join(__dirname, 'fixtures/server.crt'), 'utf8'), fs.promises.readFile(path.join(__dirname, 'fixtures/server.key'), 'utf8'), install.test.readCAFile(cafile)]));

        case 4:
          _ref = _context2.sent;
          _ref2 = _slicedToArray(_ref, 3);
          cert = _ref2[0];
          key = _ref2[1];
          ca = _ref2[2];
          t.strictEqual(ca.length, 1);
          options = {
            ca: ca,
            cert: cert,
            key: key
          };
          server = https.createServer(options, function (req, res) {
            t.strictEqual(req.headers['user-agent'], "node-gyp v42 (node ".concat(process.version, ")"));
            res.end('ok');
          });
          t.tearDown(function () {
            return new Promise(function (resolve) {
              return server.close(resolve);
            });
          });
          server.on('clientError', function (err) {
            throw err;
          });
          host = 'localhost';
          _context2.next = 17;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return server.listen(0, host, resolve);
          }));

        case 17:
          _server$address2 = server.address(), port = _server$address2.port;
          gyp = {
            opts: {
              cafile: cafile
            },
            version: '42'
          };
          url = "https://".concat(host, ":").concat(port);
          _context2.next = 22;
          return regeneratorRuntime.awrap(install.test.download(gyp, url));

        case 22:
          res = _context2.sent;
          _context2.t0 = t;
          _context2.next = 26;
          return regeneratorRuntime.awrap(res.text());

        case 26:
          _context2.t1 = _context2.sent;

          _context2.t0.strictEqual.call(_context2.t0, _context2.t1, 'ok');

        case 28:
        case "end":
          return _context2.stop();
      }
    }
  });
});
test('download over http with proxy', function _callee3(t) {
  var server, pserver, host, _server$address3, port, gyp, url, res;

  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          t.plan(2);
          server = http.createServer(function (_, res) {
            res.end('ok');
          });
          pserver = http.createServer(function (req, res) {
            t.strictEqual(req.headers['user-agent'], "node-gyp v42 (node ".concat(process.version, ")"));
            res.end('proxy ok');
          });
          t.tearDown(function () {
            return Promise.all([new Promise(function (resolve) {
              return server.close(resolve);
            }), new Promise(function (resolve) {
              return pserver.close(resolve);
            })]);
          });
          host = 'localhost';
          _context3.next = 7;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return server.listen(0, host, resolve);
          }));

        case 7:
          _server$address3 = server.address(), port = _server$address3.port;
          _context3.next = 10;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return pserver.listen(port + 1, host, resolve);
          }));

        case 10:
          gyp = {
            opts: {
              proxy: "http://".concat(host, ":").concat(port + 1),
              noproxy: 'bad'
            },
            version: '42'
          };
          url = "http://".concat(host, ":").concat(port);
          _context3.next = 14;
          return regeneratorRuntime.awrap(install.test.download(gyp, url));

        case 14:
          res = _context3.sent;
          _context3.t0 = t;
          _context3.next = 18;
          return regeneratorRuntime.awrap(res.text());

        case 18:
          _context3.t1 = _context3.sent;

          _context3.t0.strictEqual.call(_context3.t0, _context3.t1, 'proxy ok');

        case 20:
        case "end":
          return _context3.stop();
      }
    }
  });
});
test('download over http with noproxy', function _callee4(t) {
  var server, pserver, host, _server$address4, port, gyp, url, res;

  return regeneratorRuntime.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          t.plan(2);
          server = http.createServer(function (req, res) {
            t.strictEqual(req.headers['user-agent'], "node-gyp v42 (node ".concat(process.version, ")"));
            res.end('ok');
          });
          pserver = http.createServer(function (_, res) {
            res.end('proxy ok');
          });
          t.tearDown(function () {
            return Promise.all([new Promise(function (resolve) {
              return server.close(resolve);
            }), new Promise(function (resolve) {
              return pserver.close(resolve);
            })]);
          });
          host = 'localhost';
          _context4.next = 7;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return server.listen(0, host, resolve);
          }));

        case 7:
          _server$address4 = server.address(), port = _server$address4.port;
          _context4.next = 10;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return pserver.listen(port + 1, host, resolve);
          }));

        case 10:
          gyp = {
            opts: {
              proxy: "http://".concat(host, ":").concat(port + 1),
              noproxy: host
            },
            version: '42'
          };
          url = "http://".concat(host, ":").concat(port);
          _context4.next = 14;
          return regeneratorRuntime.awrap(install.test.download(gyp, url));

        case 14:
          res = _context4.sent;
          _context4.t0 = t;
          _context4.next = 18;
          return regeneratorRuntime.awrap(res.text());

        case 18:
          _context4.t1 = _context4.sent;

          _context4.t0.strictEqual.call(_context4.t0, _context4.t1, 'ok');

        case 20:
        case "end":
          return _context4.stop();
      }
    }
  });
});
test('download with missing cafile', function _callee5(t) {
  var gyp;
  return regeneratorRuntime.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          t.plan(1);
          gyp = {
            opts: {
              cafile: 'no.such.file'
            }
          };
          _context5.prev = 2;
          _context5.next = 5;
          return regeneratorRuntime.awrap(install.test.download(gyp, {}, 'http://bad/'));

        case 5:
          _context5.next = 10;
          break;

        case 7:
          _context5.prev = 7;
          _context5.t0 = _context5["catch"](2);
          t.ok(/no.such.file/.test(_context5.t0.message));

        case 10:
        case "end":
          return _context5.stop();
      }
    }
  }, null, null, [[2, 7]]);
});
test('check certificate splitting', function _callee6(t) {
  var cas;
  return regeneratorRuntime.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return regeneratorRuntime.awrap(install.test.readCAFile(path.join(__dirname, 'fixtures/ca-bundle.crt')));

        case 2:
          cas = _context6.sent;
          t.plan(2);
          t.strictEqual(cas.length, 2);
          t.notStrictEqual(cas[0], cas[1]);

        case 6:
        case "end":
          return _context6.stop();
      }
    }
  });
}); // only run this test if we are running a version of Node with predictable version path behavior

test('download headers (actual)', function _callee7(t) {
  var expectedDir, prog, data, list, lines, version;
  return regeneratorRuntime.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          if (!(process.env.FAST_TEST || process.release.name !== 'node' || semver.prerelease(process.version) !== null || semver.satisfies(process.version, '<10'))) {
            _context7.next = 2;
            break;
          }

          return _context7.abrupt("return", t.skip('Skipping actual download of headers due to test environment configuration'));

        case 2:
          t.plan(12);
          expectedDir = path.join(devDir, process.version.replace(/^v/, ''));
          _context7.next = 6;
          return regeneratorRuntime.awrap(util.promisify(rimraf)(expectedDir));

        case 6:
          prog = gyp();
          prog.parseArgv([]);
          prog.devDir = devDir;
          log.level = 'warn';
          _context7.next = 12;
          return regeneratorRuntime.awrap(util.promisify(install)(prog, []));

        case 12:
          _context7.next = 14;
          return regeneratorRuntime.awrap(fs.promises.readFile(path.join(expectedDir, 'installVersion'), 'utf8'));

        case 14:
          data = _context7.sent;
          t.strictEqual(data, '9\n', 'correct installVersion');
          _context7.next = 18;
          return regeneratorRuntime.awrap(fs.promises.readdir(path.join(expectedDir, 'include/node')));

        case 18:
          list = _context7.sent;
          t.ok(list.includes('common.gypi'));
          t.ok(list.includes('config.gypi'));
          t.ok(list.includes('node.h'));
          t.ok(list.includes('node_version.h'));
          t.ok(list.includes('openssl'));
          t.ok(list.includes('uv'));
          t.ok(list.includes('uv.h'));
          t.ok(list.includes('v8-platform.h'));
          t.ok(list.includes('v8.h'));
          t.ok(list.includes('zlib.h'));
          _context7.next = 31;
          return regeneratorRuntime.awrap(fs.promises.readFile(path.join(expectedDir, 'include/node/node_version.h'), 'utf8'));

        case 31:
          lines = _context7.sent.split('\n');
          // extract the 3 version parts from the defines to build a valid version string and
          // and check them against our current env version
          version = ['major', 'minor', 'patch'].reduce(function (version, type) {
            var re = new RegExp("^#define\\sNODE_".concat(type.toUpperCase(), "_VERSION"));
            var line = lines.find(function (l) {
              return re.test(l);
            });
            var i = line ? parseInt(line.replace(/^[^0-9]+([0-9]+).*$/, '$1'), 10) : 'ERROR';
            return "".concat(version).concat(type !== 'major' ? '.' : 'v').concat(i);
          }, '');
          t.strictEqual(version, process.version);

        case 34:
        case "end":
          return _context7.stop();
      }
    }
  });
});