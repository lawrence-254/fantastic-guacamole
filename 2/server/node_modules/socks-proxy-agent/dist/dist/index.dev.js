"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SocksProxyAgent = void 0;

var socks_1 = require("socks");

var agent_base_1 = require("agent-base");

var debug_1 = __importDefault(require("debug"));

var dns_1 = __importDefault(require("dns"));

var tls_1 = __importDefault(require("tls"));

var debug = (0, debug_1["default"])('socks-proxy-agent');

function parseSocksProxy(opts) {
  var _a;

  var port = 0;
  var lookup = false;
  var type = 5;
  var host = opts.hostname || opts.host;

  if (host == null) {
    throw new TypeError('No "hostname"');
  }

  if (typeof opts.port === 'number') {
    port = opts.port;
  } else if (typeof opts.port === 'string') {
    port = parseInt(opts.port, 10);
  } // From RFC 1928, Section 3: https://tools.ietf.org/html/rfc1928#section-3
  // "The SOCKS service is conventionally located on TCP port 1080"


  if (port == null) {
    port = 1080;
  } // figure out if we want socks v4 or v5, based on the "protocol" used.
  // Defaults to 5.


  if (opts.protocol != null) {
    switch (opts.protocol.replace(':', '')) {
      case 'socks4':
        lookup = true;
      // pass through

      case 'socks4a':
        type = 4;
        break;

      case 'socks5':
        lookup = true;
      // pass through

      case 'socks': // no version specified, default to 5h

      case 'socks5h':
        type = 5;
        break;

      default:
        throw new TypeError("A \"socks\" protocol must be specified! Got: ".concat(String(opts.protocol)));
    }
  }

  if (typeof opts.type !== 'undefined') {
    if (opts.type === 4 || opts.type === 5) {
      type = opts.type;
    } else {
      throw new TypeError("\"type\" must be 4 or 5, got: ".concat(String(opts.type)));
    }
  }

  var proxy = {
    host: host,
    port: port,
    type: type
  };
  var userId = (_a = opts.userId) !== null && _a !== void 0 ? _a : opts.username;
  var password = opts.password;

  if (opts.auth != null) {
    var auth = opts.auth.split(':');
    userId = auth[0];
    password = auth[1];
  }

  if (userId != null) {
    Object.defineProperty(proxy, 'userId', {
      value: userId,
      enumerable: false
    });
  }

  if (password != null) {
    Object.defineProperty(proxy, 'password', {
      value: password,
      enumerable: false
    });
  }

  return {
    lookup: lookup,
    proxy: proxy
  };
}

var normalizeProxyOptions = function normalizeProxyOptions(input) {
  var proxyOptions;

  if (typeof input === 'string') {
    proxyOptions = new URL(input);
  } else {
    proxyOptions = input;
  }

  if (proxyOptions == null) {
    throw new TypeError('a SOCKS proxy server `hostname` and `port` must be specified!');
  }

  return proxyOptions;
};

var SocksProxyAgent =
/*#__PURE__*/
function (_agent_base_1$Agent) {
  _inherits(SocksProxyAgent, _agent_base_1$Agent);

  function SocksProxyAgent(input, options) {
    var _this;

    _classCallCheck(this, SocksProxyAgent);

    var _a;

    var proxyOptions = normalizeProxyOptions(input);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(SocksProxyAgent).call(this, proxyOptions));
    var parsedProxy = parseSocksProxy(proxyOptions);
    _this.shouldLookup = parsedProxy.lookup;
    _this.proxy = parsedProxy.proxy;
    _this.tlsConnectionOptions = proxyOptions.tls != null ? proxyOptions.tls : {};
    _this.timeout = (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : null;
    return _this;
  }
  /**
   * Initiates a SOCKS connection to the specified SOCKS proxy server,
   * which in turn connects to the specified remote host and port.
   *
   * @api protected
   */


  _createClass(SocksProxyAgent, [{
    key: "callback",
    value: function callback(req, opts) {
      var _a;

      return __awaiter(this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var shouldLookup, proxy, timeout, host, port, lookupCallback, socksOpts, cleanup, _ref, socket, servername, tlsSocket;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                shouldLookup = this.shouldLookup, proxy = this.proxy, timeout = this.timeout;
                host = opts.host, port = opts.port, lookupCallback = opts.lookup;

                if (!(host == null)) {
                  _context.next = 4;
                  break;
                }

                throw new Error('No `host` defined!');

              case 4:
                if (!shouldLookup) {
                  _context.next = 8;
                  break;
                }

                _context.next = 7;
                return new Promise(function (resolve, reject) {
                  // Use the request's custom lookup, if one was configured:
                  var lookupFn = lookupCallback !== null && lookupCallback !== void 0 ? lookupCallback : dns_1["default"].lookup;
                  lookupFn(host, {}, function (err, res) {
                    if (err) {
                      reject(err);
                    } else {
                      resolve(res);
                    }
                  });
                });

              case 7:
                host = _context.sent;

              case 8:
                socksOpts = {
                  proxy: proxy,
                  destination: {
                    host: host,
                    port: port
                  },
                  command: 'connect',
                  timeout: timeout !== null && timeout !== void 0 ? timeout : undefined
                };

                cleanup = function cleanup(tlsSocket) {
                  req.destroy();
                  socket.destroy();
                  if (tlsSocket) tlsSocket.destroy();
                };

                debug('Creating socks proxy connection: %o', socksOpts);
                _context.next = 13;
                return socks_1.SocksClient.createConnection(socksOpts);

              case 13:
                _ref = _context.sent;
                socket = _ref.socket;
                debug('Successfully created socks proxy connection');

                if (timeout !== null) {
                  socket.setTimeout(timeout);
                  socket.on('timeout', function () {
                    return cleanup();
                  });
                }

                if (!opts.secureEndpoint) {
                  _context.next = 23;
                  break;
                }

                // The proxy is connecting to a TLS server, so upgrade
                // this socket connection to a TLS connection.
                debug('Upgrading socket connection to TLS');
                servername = (_a = opts.servername) !== null && _a !== void 0 ? _a : opts.host;
                tlsSocket = tls_1["default"].connect(Object.assign(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), {
                  socket: socket,
                  servername: servername
                }), this.tlsConnectionOptions));
                tlsSocket.once('error', function (error) {
                  debug('socket TLS error', error.message);
                  cleanup(tlsSocket);
                });
                return _context.abrupt("return", tlsSocket);

              case 23:
                return _context.abrupt("return", socket);

              case 24:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }
  }]);

  return SocksProxyAgent;
}(agent_base_1.Agent);

exports.SocksProxyAgent = SocksProxyAgent;

function omit(obj) {
  var ret = {};
  var key;

  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }

  return ret;
}