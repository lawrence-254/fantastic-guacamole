"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SocksClientError = exports.SocksClient = void 0;

var events_1 = require("events");

var net = require("net");

var smart_buffer_1 = require("smart-buffer");

var constants_1 = require("../common/constants");

var helpers_1 = require("../common/helpers");

var receivebuffer_1 = require("../common/receivebuffer");

var util_1 = require("../common/util");

Object.defineProperty(exports, "SocksClientError", {
  enumerable: true,
  get: function get() {
    return util_1.SocksClientError;
  }
});

var ip_address_1 = require("ip-address");

var SocksClient =
/*#__PURE__*/
function (_events_1$EventEmitte) {
  _inherits(SocksClient, _events_1$EventEmitte);

  function SocksClient(options) {
    var _this;

    _classCallCheck(this, SocksClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SocksClient).call(this));
    _this.options = Object.assign({}, options); // Validate SocksClientOptions

    (0, helpers_1.validateSocksClientOptions)(options); // Default state

    _this.setState(constants_1.SocksClientState.Created);

    return _this;
  }
  /**
   * Creates a new SOCKS connection.
   *
   * Note: Supports callbacks and promises. Only supports the connect command.
   * @param options { SocksClientOptions } Options.
   * @param callback { Function } An optional callback function.
   * @returns { Promise }
   */


  _createClass(SocksClient, [{
    key: "setState",

    /**
     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
     */
    value: function setState(newState) {
      if (this.state !== constants_1.SocksClientState.Error) {
        this.state = newState;
      }
    }
    /**
     * Starts the connection establishment to the proxy and destination.
     * @param existingSocket Connected socket to use instead of creating a new one (internal use).
     */

  }, {
    key: "connect",
    value: function connect(existingSocket) {
      var _this2 = this;

      this.onDataReceived = function (data) {
        return _this2.onDataReceivedHandler(data);
      };

      this.onClose = function () {
        return _this2.onCloseHandler();
      };

      this.onError = function (err) {
        return _this2.onErrorHandler(err);
      };

      this.onConnect = function () {
        return _this2.onConnectHandler();
      }; // Start timeout timer (defaults to 30 seconds)


      var timer = setTimeout(function () {
        return _this2.onEstablishedTimeout();
      }, this.options.timeout || constants_1.DEFAULT_TIMEOUT); // check whether unref is available as it differs from browser to NodeJS (#33)

      if (timer.unref && typeof timer.unref === 'function') {
        timer.unref();
      } // If an existing socket is provided, use it to negotiate SOCKS handshake. Otherwise create a new Socket.


      if (existingSocket) {
        this.socket = existingSocket;
      } else {
        this.socket = new net.Socket();
      } // Attach Socket error handlers.


      this.socket.once('close', this.onClose);
      this.socket.once('error', this.onError);
      this.socket.once('connect', this.onConnect);
      this.socket.on('data', this.onDataReceived);
      this.setState(constants_1.SocksClientState.Connecting);
      this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();

      if (existingSocket) {
        this.socket.emit('connect');
      } else {
        this.socket.connect(this.getSocketOptions());

        if (this.options.set_tcp_nodelay !== undefined && this.options.set_tcp_nodelay !== null) {
          this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
        }
      } // Listen for established event so we can re-emit any excess data received during handshakes.


      this.prependOnceListener('established', function (info) {
        setImmediate(function () {
          if (_this2.receiveBuffer.length > 0) {
            var excessData = _this2.receiveBuffer.get(_this2.receiveBuffer.length);

            info.socket.emit('data', excessData);
          }

          info.socket.resume();
        });
      });
    } // Socket options (defaults host/port to options.proxy.host/options.proxy.port)

  }, {
    key: "getSocketOptions",
    value: function getSocketOptions() {
      return Object.assign(Object.assign({}, this.options.socket_options), {
        host: this.options.proxy.host || this.options.proxy.ipaddress,
        port: this.options.proxy.port
      });
    }
    /**
     * Handles internal Socks timeout callback.
     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
     */

  }, {
    key: "onEstablishedTimeout",
    value: function onEstablishedTimeout() {
      if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
        this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
      }
    }
    /**
     * Handles Socket connect event.
     */

  }, {
    key: "onConnectHandler",
    value: function onConnectHandler() {
      this.setState(constants_1.SocksClientState.Connected); // Send initial handshake.

      if (this.options.proxy.type === 4) {
        this.sendSocks4InitialHandshake();
      } else {
        this.sendSocks5InitialHandshake();
      }

      this.setState(constants_1.SocksClientState.SentInitialHandshake);
    }
    /**
     * Handles Socket data event.
     * @param data
     */

  }, {
    key: "onDataReceivedHandler",
    value: function onDataReceivedHandler(data) {
      /*
        All received data is appended to a ReceiveBuffer.
        This makes sure that all the data we need is received before we attempt to process it.
      */
      this.receiveBuffer.append(data); // Process data that we have.

      this.processData();
    }
    /**
     * Handles processing of the data we have received.
     */

  }, {
    key: "processData",
    value: function processData() {
      // If we have enough data to process the next step in the SOCKS handshake, proceed.
      while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
        // Sent initial handshake, waiting for response.
        if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
          if (this.options.proxy.type === 4) {
            // Socks v4 only has one handshake response.
            this.handleSocks4FinalHandshakeResponse();
          } else {
            // Socks v5 has two handshakes, handle initial one here.
            this.handleInitialSocks5HandshakeResponse();
          } // Sent auth request for Socks v5, waiting for response.

        } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
          this.handleInitialSocks5AuthenticationHandshakeResponse(); // Sent final Socks v5 handshake, waiting for final response.
        } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
          this.handleSocks5FinalHandshakeResponse(); // Socks BIND established. Waiting for remote connection via proxy.
        } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4IncomingConnectionResponse();
          } else {
            this.handleSocks5IncomingConnectionResponse();
          }
        } else {
          this.closeSocket(constants_1.ERRORS.InternalError);
          break;
        }
      }
    }
    /**
     * Handles Socket close event.
     * @param had_error
     */

  }, {
    key: "onCloseHandler",
    value: function onCloseHandler() {
      this.closeSocket(constants_1.ERRORS.SocketClosed);
    }
    /**
     * Handles Socket error event.
     * @param err
     */

  }, {
    key: "onErrorHandler",
    value: function onErrorHandler(err) {
      this.closeSocket(err.message);
    }
    /**
     * Removes internal event listeners on the underlying Socket.
     */

  }, {
    key: "removeInternalSocketHandlers",
    value: function removeInternalSocketHandlers() {
      // Pauses data flow of the socket (this is internally resumed after 'established' is emitted)
      this.socket.pause();
      this.socket.removeListener('data', this.onDataReceived);
      this.socket.removeListener('close', this.onClose);
      this.socket.removeListener('error', this.onError);
      this.socket.removeListener('connect', this.onConnect);
    }
    /**
     * Closes and destroys the underlying Socket. Emits an error event.
     * @param err { String } An error string to include in error event.
     */

  }, {
    key: "closeSocket",
    value: function closeSocket(err) {
      // Make sure only one 'error' event is fired for the lifetime of this SocksClient instance.
      if (this.state !== constants_1.SocksClientState.Error) {
        // Set internal state to Error.
        this.setState(constants_1.SocksClientState.Error); // Destroy Socket

        this.socket.destroy(); // Remove internal listeners

        this.removeInternalSocketHandlers(); // Fire 'error' event.

        this.emit('error', new util_1.SocksClientError(err, this.options));
      }
    }
    /**
     * Sends initial Socks v4 handshake request.
     */

  }, {
    key: "sendSocks4InitialHandshake",
    value: function sendSocks4InitialHandshake() {
      var userId = this.options.proxy.userId || '';
      var buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(0x04);
      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
      buff.writeUInt16BE(this.options.destination.port); // Socks 4 (IPv4)

      if (net.isIPv4(this.options.destination.host)) {
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        buff.writeStringNT(userId); // Socks 4a (hostname)
      } else {
        buff.writeUInt8(0x00);
        buff.writeUInt8(0x00);
        buff.writeUInt8(0x00);
        buff.writeUInt8(0x01);
        buff.writeStringNT(userId);
        buff.writeStringNT(this.options.destination.host);
      }

      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
      this.socket.write(buff.toBuffer());
    }
    /**
     * Handles Socks v4 handshake response.
     * @param data
     */

  }, {
    key: "handleSocks4FinalHandshakeResponse",
    value: function handleSocks4FinalHandshakeResponse() {
      var data = this.receiveBuffer.get(8);

      if (data[1] !== constants_1.Socks4Response.Granted) {
        this.closeSocket("".concat(constants_1.ERRORS.Socks4ProxyRejectedConnection, " - (").concat(constants_1.Socks4Response[data[1]], ")"));
      } else {
        // Bind response
        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
          var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          var remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          }; // If host is 0.0.0.0, set to proxy host.

          if (remoteHost.host === '0.0.0.0') {
            remoteHost.host = this.options.proxy.ipaddress;
          }

          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
          this.emit('bound', {
            remoteHost: remoteHost,
            socket: this.socket
          }); // Connect response
        } else {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit('established', {
            socket: this.socket
          });
        }
      }
    }
    /**
     * Handles Socks v4 incoming connection request (BIND)
     * @param data
     */

  }, {
    key: "handleSocks4IncomingConnectionResponse",
    value: function handleSocks4IncomingConnectionResponse() {
      var data = this.receiveBuffer.get(8);

      if (data[1] !== constants_1.Socks4Response.Granted) {
        this.closeSocket("".concat(constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection, " - (").concat(constants_1.Socks4Response[data[1]], ")"));
      } else {
        var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        var remoteHost = {
          port: buff.readUInt16BE(),
          host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
        };
        this.setState(constants_1.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit('established', {
          remoteHost: remoteHost,
          socket: this.socket
        });
      }
    }
    /**
     * Sends initial Socks v5 handshake request.
     */

  }, {
    key: "sendSocks5InitialHandshake",
    value: function sendSocks5InitialHandshake() {
      var buff = new smart_buffer_1.SmartBuffer(); // By default we always support no auth.

      var supportedAuthMethods = [constants_1.Socks5Auth.NoAuth]; // We should only tell the proxy we support user/pass auth if auth info is actually provided.
      // Note: As of Tor v0.3.5.7+, if user/pass auth is an option from the client, by default it will always take priority.

      if (this.options.proxy.userId || this.options.proxy.password) {
        supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
      } // Custom auth method?


      if (this.options.proxy.custom_auth_method !== undefined) {
        supportedAuthMethods.push(this.options.proxy.custom_auth_method);
      } // Build handshake packet


      buff.writeUInt8(0x05);
      buff.writeUInt8(supportedAuthMethods.length);

      for (var _i = 0, _supportedAuthMethods = supportedAuthMethods; _i < _supportedAuthMethods.length; _i++) {
        var authMethod = _supportedAuthMethods[_i];
        buff.writeUInt8(authMethod);
      }

      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentInitialHandshake);
    }
    /**
     * Handles initial Socks v5 handshake response.
     * @param data
     */

  }, {
    key: "handleInitialSocks5HandshakeResponse",
    value: function handleInitialSocks5HandshakeResponse() {
      var data = this.receiveBuffer.get(2);

      if (data[0] !== 0x05) {
        this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
      } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
        this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
      } else {
        // If selected Socks v5 auth method is no auth, send final handshake request.
        if (data[1] === constants_1.Socks5Auth.NoAuth) {
          this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
          this.sendSocks5CommandRequest(); // If selected Socks v5 auth method is user/password, send auth handshake.
        } else if (data[1] === constants_1.Socks5Auth.UserPass) {
          this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
          this.sendSocks5UserPassAuthentication(); // If selected Socks v5 auth method is the custom_auth_method, send custom handshake.
        } else if (data[1] === this.options.proxy.custom_auth_method) {
          this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
          this.sendSocks5CustomAuthentication();
        } else {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
        }
      }
    }
    /**
     * Sends Socks v5 user & password auth handshake.
     *
     * Note: No auth and user/pass are currently supported.
     */

  }, {
    key: "sendSocks5UserPassAuthentication",
    value: function sendSocks5UserPassAuthentication() {
      var userId = this.options.proxy.userId || '';
      var password = this.options.proxy.password || '';
      var buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(0x01);
      buff.writeUInt8(Buffer.byteLength(userId));
      buff.writeString(userId);
      buff.writeUInt8(Buffer.byteLength(password));
      buff.writeString(password);
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentAuthentication);
    }
  }, {
    key: "sendSocks5CustomAuthentication",
    value: function sendSocks5CustomAuthentication() {
      return __awaiter(this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
                _context.t0 = this.socket;
                _context.next = 4;
                return this.options.proxy.custom_auth_request_handler();

              case 4:
                _context.t1 = _context.sent;

                _context.t0.write.call(_context.t0, _context.t1);

                this.setState(constants_1.SocksClientState.SentAuthentication);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "handleSocks5CustomAuthHandshakeResponse",
    value: function handleSocks5CustomAuthHandshakeResponse(data) {
      return __awaiter(this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.options.proxy.custom_auth_response_handler(data);

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "handleSocks5AuthenticationNoAuthHandshakeResponse",
    value: function handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
      return __awaiter(this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", data[1] === 0x00);

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
    }
  }, {
    key: "handleSocks5AuthenticationUserPassHandshakeResponse",
    value: function handleSocks5AuthenticationUserPassHandshakeResponse(data) {
      return __awaiter(this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", data[1] === 0x00);

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
    }
    /**
     * Handles Socks v5 auth handshake response.
     * @param data
     */

  }, {
    key: "handleInitialSocks5AuthenticationHandshakeResponse",
    value: function handleInitialSocks5AuthenticationHandshakeResponse() {
      return __awaiter(this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var authResult;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
                authResult = false;

                if (!(this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth)) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 5;
                return this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));

              case 5:
                authResult = _context5.sent;
                _context5.next = 18;
                break;

              case 8:
                if (!(this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass)) {
                  _context5.next = 14;
                  break;
                }

                _context5.next = 11;
                return this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));

              case 11:
                authResult = _context5.sent;
                _context5.next = 18;
                break;

              case 14:
                if (!(this.socks5ChosenAuthType === this.options.proxy.custom_auth_method)) {
                  _context5.next = 18;
                  break;
                }

                _context5.next = 17;
                return this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));

              case 17:
                authResult = _context5.sent;

              case 18:
                if (!authResult) {
                  this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
                } else {
                  this.sendSocks5CommandRequest();
                }

              case 19:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
    }
    /**
     * Sends Socks v5 final handshake request.
     */

  }, {
    key: "sendSocks5CommandRequest",
    value: function sendSocks5CommandRequest() {
      var buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(0x05);
      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
      buff.writeUInt8(0x00); // ipv4, ipv6, domain?

      if (net.isIPv4(this.options.destination.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv4);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else if (net.isIPv6(this.options.destination.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else {
        buff.writeUInt8(constants_1.Socks5HostType.Hostname);
        buff.writeUInt8(this.options.destination.host.length);
        buff.writeString(this.options.destination.host);
      }

      buff.writeUInt16BE(this.options.destination.port);
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentFinalHandshake);
    }
    /**
     * Handles Socks v5 final handshake response.
     * @param data
     */

  }, {
    key: "handleSocks5FinalHandshakeResponse",
    value: function handleSocks5FinalHandshakeResponse() {
      // Peek at available data (we need at least 5 bytes to get the hostname length)
      var header = this.receiveBuffer.peek(5);

      if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {
        this.closeSocket("".concat(constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected, " - ").concat(constants_1.Socks5Response[header[1]]));
      } else {
        // Read address type
        var addressType = header[3];
        var remoteHost;
        var buff; // IPv4

        if (addressType === constants_1.Socks5HostType.IPv4) {
          // Check if data is available.
          var dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;

          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }

          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          }; // If given host is 0.0.0.0, assume remote proxy ip instead.

          if (remoteHost.host === '0.0.0.0') {
            remoteHost.host = this.options.proxy.ipaddress;
          } // Hostname

        } else if (addressType === constants_1.Socks5HostType.Hostname) {
          var hostLength = header[4];

          var _dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + host + port
          // Check if data is available.


          if (this.receiveBuffer.length < _dataNeeded) {
            this.nextRequiredPacketBufferSize = _dataNeeded;
            return;
          }

          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          }; // IPv6
        } else if (addressType === constants_1.Socks5HostType.IPv6) {
          // Check if data is available.
          var _dataNeeded2 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;

          if (this.receiveBuffer.length < _dataNeeded2) {
            this.nextRequiredPacketBufferSize = _dataNeeded2;
            return;
          }

          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded2).slice(4));
          remoteHost = {
            host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        } // We have everything we need


        this.setState(constants_1.SocksClientState.ReceivedFinalResponse); // If using CONNECT, the client is now in the established state.

        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit('established', {
            remoteHost: remoteHost,
            socket: this.socket
          });
        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
          /* If using BIND, the Socks client is now in BoundWaitingForConnection state.
             This means that the remote proxy server is waiting for a remote connection to the bound port. */
          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
          this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
          this.emit('bound', {
            remoteHost: remoteHost,
            socket: this.socket
          });
          /*
            If using Associate, the Socks client is now Established. And the proxy server is now accepting UDP packets at the
            given bound port. This initial Socks TCP connection must remain open for the UDP relay to continue to work.
          */
        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit('established', {
            remoteHost: remoteHost,
            socket: this.socket
          });
        }
      }
    }
    /**
     * Handles Socks v5 incoming connection request (BIND).
     */

  }, {
    key: "handleSocks5IncomingConnectionResponse",
    value: function handleSocks5IncomingConnectionResponse() {
      // Peek at available data (we need at least 5 bytes to get the hostname length)
      var header = this.receiveBuffer.peek(5);

      if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {
        this.closeSocket("".concat(constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection, " - ").concat(constants_1.Socks5Response[header[1]]));
      } else {
        // Read address type
        var addressType = header[3];
        var remoteHost;
        var buff; // IPv4

        if (addressType === constants_1.Socks5HostType.IPv4) {
          // Check if data is available.
          var dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;

          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }

          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          }; // If given host is 0.0.0.0, assume remote proxy ip instead.

          if (remoteHost.host === '0.0.0.0') {
            remoteHost.host = this.options.proxy.ipaddress;
          } // Hostname

        } else if (addressType === constants_1.Socks5HostType.Hostname) {
          var hostLength = header[4];

          var _dataNeeded3 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + port
          // Check if data is available.


          if (this.receiveBuffer.length < _dataNeeded3) {
            this.nextRequiredPacketBufferSize = _dataNeeded3;
            return;
          }

          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded3).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          }; // IPv6
        } else if (addressType === constants_1.Socks5HostType.IPv6) {
          // Check if data is available.
          var _dataNeeded4 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;

          if (this.receiveBuffer.length < _dataNeeded4) {
            this.nextRequiredPacketBufferSize = _dataNeeded4;
            return;
          }

          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded4).slice(4));
          remoteHost = {
            host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        }

        this.setState(constants_1.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit('established', {
          remoteHost: remoteHost,
          socket: this.socket
        });
      }
    }
  }, {
    key: "socksClientOptions",
    get: function get() {
      return Object.assign({}, this.options);
    }
  }], [{
    key: "createConnection",
    value: function createConnection(options, callback) {
      return new Promise(function (resolve, reject) {
        // Validate SocksClientOptions
        try {
          (0, helpers_1.validateSocksClientOptions)(options, ['connect']);
        } catch (err) {
          if (typeof callback === 'function') {
            callback(err); // eslint-disable-next-line @typescript-eslint/no-explicit-any

            return resolve(err); // Resolves pending promise (prevents memory leaks).
          } else {
            return reject(err);
          }
        }

        var client = new SocksClient(options);
        client.connect(options.existing_socket);
        client.once('established', function (info) {
          client.removeAllListeners();

          if (typeof callback === 'function') {
            callback(null, info);
            resolve(info); // Resolves pending promise (prevents memory leaks).
          } else {
            resolve(info);
          }
        }); // Error occurred, failed to establish connection.

        client.once('error', function (err) {
          client.removeAllListeners();

          if (typeof callback === 'function') {
            callback(err); // eslint-disable-next-line @typescript-eslint/no-explicit-any

            resolve(err); // Resolves pending promise (prevents memory leaks).
          } else {
            reject(err);
          }
        });
      });
    }
    /**
     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
     *
     * Note: Supports callbacks and promises. Only supports the connect method.
     * Note: Implemented via createConnection() factory function.
     * @param options { SocksClientChainOptions } Options
     * @param callback { Function } An optional callback function.
     * @returns { Promise }
     */

  }, {
    key: "createConnectionChain",
    value: function createConnectionChain(options, callback) {
      var _this3 = this;

      // eslint-disable-next-line no-async-promise-executor
      return new Promise(function (resolve, reject) {
        return __awaiter(_this3, void 0, void 0,
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee6() {
          var sock, i, nextProxy, nextDestination, result;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.prev = 0;
                  (0, helpers_1.validateSocksClientChainOptions)(options);
                  _context6.next = 12;
                  break;

                case 4:
                  _context6.prev = 4;
                  _context6.t0 = _context6["catch"](0);

                  if (!(typeof callback === 'function')) {
                    _context6.next = 11;
                    break;
                  }

                  callback(_context6.t0); // eslint-disable-next-line @typescript-eslint/no-explicit-any

                  return _context6.abrupt("return", resolve(_context6.t0));

                case 11:
                  return _context6.abrupt("return", reject(_context6.t0));

                case 12:
                  // Shuffle proxies
                  if (options.randomizeChain) {
                    (0, util_1.shuffleArray)(options.proxies);
                  }

                  _context6.prev = 13;
                  i = 0;

                case 15:
                  if (!(i < options.proxies.length)) {
                    _context6.next = 25;
                    break;
                  }

                  nextProxy = options.proxies[i]; // If we've reached the last proxy in the chain, the destination is the actual destination, otherwise it's the next proxy.

                  nextDestination = i === options.proxies.length - 1 ? options.destination : {
                    host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
                    port: options.proxies[i + 1].port
                  }; // Creates the next connection in the chain.

                  _context6.next = 20;
                  return SocksClient.createConnection({
                    command: 'connect',
                    proxy: nextProxy,
                    destination: nextDestination,
                    existing_socket: sock
                  });

                case 20:
                  result = _context6.sent;
                  // If sock is undefined, assign it here.
                  sock = sock || result.socket;

                case 22:
                  i++;
                  _context6.next = 15;
                  break;

                case 25:
                  if (typeof callback === 'function') {
                    callback(null, {
                      socket: sock
                    });
                    resolve({
                      socket: sock
                    }); // Resolves pending promise (prevents memory leaks).
                  } else {
                    resolve({
                      socket: sock
                    });
                  }

                  _context6.next = 31;
                  break;

                case 28:
                  _context6.prev = 28;
                  _context6.t1 = _context6["catch"](13);

                  if (typeof callback === 'function') {
                    callback(_context6.t1); // eslint-disable-next-line @typescript-eslint/no-explicit-any

                    resolve(_context6.t1); // Resolves pending promise (prevents memory leaks).
                  } else {
                    reject(_context6.t1);
                  }

                case 31:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, null, [[0, 4], [13, 28]]);
        }));
      });
    }
    /**
     * Creates a SOCKS UDP Frame.
     * @param options
     */

  }, {
    key: "createUDPFrame",
    value: function createUDPFrame(options) {
      var buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt16BE(0);
      buff.writeUInt8(options.frameNumber || 0); // IPv4/IPv6/Hostname

      if (net.isIPv4(options.remoteHost.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv4);
        buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
      } else if (net.isIPv6(options.remoteHost.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
      } else {
        buff.writeUInt8(constants_1.Socks5HostType.Hostname);
        buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
        buff.writeString(options.remoteHost.host);
      } // Port


      buff.writeUInt16BE(options.remoteHost.port); // Data

      buff.writeBuffer(options.data);
      return buff.toBuffer();
    }
    /**
     * Parses a SOCKS UDP frame.
     * @param data
     */

  }, {
    key: "parseUDPFrame",
    value: function parseUDPFrame(data) {
      var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
      buff.readOffset = 2;
      var frameNumber = buff.readUInt8();
      var hostType = buff.readUInt8();
      var remoteHost;

      if (hostType === constants_1.Socks5HostType.IPv4) {
        remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
      } else if (hostType === constants_1.Socks5HostType.IPv6) {
        remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
      } else {
        remoteHost = buff.readString(buff.readUInt8());
      }

      var remotePort = buff.readUInt16BE();
      return {
        frameNumber: frameNumber,
        remoteHost: {
          host: remoteHost,
          port: remotePort
        },
        data: buff.readBuffer()
      };
    }
  }]);

  return SocksClient;
}(events_1.EventEmitter);

exports.SocksClient = SocksClient;