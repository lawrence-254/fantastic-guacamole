"use strict";

var _require = require('./errors.js'),
    NotCachedError = _require.NotCachedError;

var CacheEntry = require('./entry.js');

var remote = require('../remote.js'); // do whatever is necessary to get a Response and return it


var cacheFetch = function cacheFetch(request, options) {
  var entry, response, _entry, _needsRevalidation;

  return regeneratorRuntime.async(function cacheFetch$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(CacheEntry.find(request, options));

        case 2:
          entry = _context.sent;

          if (entry) {
            _context.next = 11;
            break;
          }

          if (!(options.cache === 'only-if-cached')) {
            _context.next = 6;
            break;
          }

          throw new NotCachedError(request.url);

        case 6:
          _context.next = 8;
          return regeneratorRuntime.awrap(remote(request, options));

        case 8:
          response = _context.sent;
          _entry = new CacheEntry({
            request: request,
            response: response,
            options: options
          });
          return _context.abrupt("return", _entry.store('miss'));

        case 11:
          if (!(options.cache === 'no-cache')) {
            _context.next = 13;
            break;
          }

          return _context.abrupt("return", entry.revalidate(request, options));

        case 13:
          // if the cached entry is not stale, or if the cache mode is 'force-cache' or
          // 'only-if-cached' we can respond with the cached entry. set the status
          // based on the result of needsRevalidation and respond
          _needsRevalidation = entry.policy.needsRevalidation(request);

          if (!(options.cache === 'force-cache' || options.cache === 'only-if-cached' || !_needsRevalidation)) {
            _context.next = 16;
            break;
          }

          return _context.abrupt("return", entry.respond(request.method, options, _needsRevalidation ? 'stale' : 'hit'));

        case 16:
          return _context.abrupt("return", entry.revalidate(request, options));

        case 17:
        case "end":
          return _context.stop();
      }
    }
  });
};

cacheFetch.invalidate = function _callee(request, options) {
  return regeneratorRuntime.async(function _callee$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (options.cachePath) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt("return");

        case 2:
          return _context2.abrupt("return", CacheEntry.invalidate(request, options));

        case 3:
        case "end":
          return _context2.stop();
      }
    }
  });
};

module.exports = cacheFetch;