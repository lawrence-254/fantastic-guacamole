"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('minipass-fetch'),
    Request = _require.Request,
    Response = _require.Response;

var Minipass = require('minipass');

var MinipassCollect = require('minipass-collect');

var MinipassFlush = require('minipass-flush');

var MinipassPipeline = require('minipass-pipeline');

var cacache = require('cacache');

var url = require('url');

var CachePolicy = require('./policy.js');

var cacheKey = require('./key.js');

var remote = require('../remote.js');

var hasOwnProperty = function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}; // maximum amount of data we will buffer into memory
// if we'll exceed this, we switch to streaming


var MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB
// allow list for request headers that will be written to the cache index
// note: we will also store any request headers
// that are named in a response's vary header

var KEEP_REQUEST_HEADERS = ['accept-charset', 'accept-encoding', 'accept-language', 'accept', 'cache-control']; // allow list for response headers that will be written to the cache index
// note: we must not store the real response's age header, or when we load
// a cache policy based on the metadata it will think the cached response
// is always stale

var KEEP_RESPONSE_HEADERS = ['cache-control', 'content-encoding', 'content-language', 'content-type', 'date', 'etag', 'expires', 'last-modified', 'location', 'pragma', 'vary']; // return an object containing all metadata to be written to the index

var getMetadata = function getMetadata(request, response, options) {
  var metadata = {
    time: Date.now(),
    url: request.url,
    reqHeaders: {},
    resHeaders: {}
  }; // only save the status if it's not a 200 or 304

  if (response.status !== 200 && response.status !== 304) metadata.status = response.status;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = KEEP_REQUEST_HEADERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _name = _step.value;
      if (request.headers.has(_name)) metadata.reqHeaders[_name] = request.headers.get(_name);
    } // if the request's host header differs from the host in the url
    // we need to keep it, otherwise it's just noise and we ignore it

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var host = request.headers.get('host');
  var parsedUrl = new url.URL(request.url);
  if (host && parsedUrl.host !== host) metadata.reqHeaders.host = host; // if the response has a vary header, make sure
  // we store the relevant request headers too

  if (response.headers.has('vary')) {
    var vary = response.headers.get('vary'); // a vary of "*" means every header causes a different response.
    // in that scenario, we do not include any additional headers
    // as the freshness check will always fail anyway and we don't
    // want to bloat the cache indexes

    if (vary !== '*') {
      // copy any other request headers that will vary the response
      var varyHeaders = vary.trim().toLowerCase().split(/\s*,\s*/);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = varyHeaders[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var name = _step2.value;
          // explicitly ignore accept-encoding here
          if (name !== 'accept-encoding' && request.headers.has(name)) metadata.reqHeaders[name] = request.headers.get(name);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = KEEP_RESPONSE_HEADERS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _name2 = _step3.value;
      if (response.headers.has(_name2)) metadata.resHeaders[_name2] = response.headers.get(_name2);
    } // we only store accept-encoding and content-encoding if the user
    // has disabled automatic compression and decompression in minipass-fetch
    // since if it's enabled (the default) then the content will have
    // already been decompressed making the header a lie

  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (options.compress === false) {
    metadata.reqHeaders['accept-encoding'] = request.headers.get('accept-encoding');
    metadata.resHeaders['content-encoding'] = response.headers.get('content-encoding');
  }

  return metadata;
}; // symbols used to hide objects that may be lazily evaluated in a getter


var _request = Symbol('request');

var _response = Symbol('response');

var _policy = Symbol('policy');

var CacheEntry =
/*#__PURE__*/
function () {
  function CacheEntry(_ref) {
    var entry = _ref.entry,
        request = _ref.request,
        response = _ref.response,
        options = _ref.options;

    _classCallCheck(this, CacheEntry);

    if (entry) {
      this.key = entry.key;
      this.entry = entry; // previous versions of this module didn't write an explicit timestamp in
      // the metadata, so fall back to the entry's timestamp. we can't use the
      // entry timestamp to determine staleness because cacache will update it
      // when it verifies its data

      this.entry.metadata.time = this.entry.metadata.time || this.entry.time;
    } else this.key = cacheKey(request);

    this.options = options; // these properties are behind getters that lazily evaluate

    this[_request] = request;
    this[_response] = response;
    this[_policy] = null;
  } // returns a CacheEntry instance that satisfies the given request
  // or undefined if no existing entry satisfies


  _createClass(CacheEntry, [{
    key: "store",
    // wraps the response in a pipeline that stores the data
    // in the cache while the user consumes it
    value: function store(status) {
      var _this = this;

      var size, fitsInMemory, shouldBuffer, cacheOpts, body, cacheWriteResolve, cacheWriteReject, cacheWritePromise, abortStream, onResume, newResponse;
      return regeneratorRuntime.async(function store$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(this.request.method !== 'GET' || ![200, 301, 308].includes(this.response.status) || !this.policy.storable())) {
                _context.next = 3;
                break;
              }

              this.response.headers.set('x-local-cache-status', 'skip');
              return _context.abrupt("return", this.response);

            case 3:
              size = this.response.headers.get('content-length');
              fitsInMemory = !!size && Number(size) < MAX_MEM_SIZE;
              shouldBuffer = this.options.memoize !== false && fitsInMemory;
              cacheOpts = {
                algorithms: this.options.algorithms,
                metadata: getMetadata(this.request, this.response, this.options),
                size: size,
                memoize: fitsInMemory && this.options.memoize
              };
              body = null; // we only set a body if the status is a 200, redirects are
              // stored as metadata only

              if (!(this.response.status === 200)) {
                _context.next = 17;
                break;
              }

              cacheWritePromise = new Promise(function (resolve, reject) {
                cacheWriteResolve = resolve;
                cacheWriteReject = reject;
              });
              body = new MinipassPipeline(new MinipassFlush({
                flush: function flush() {
                  return cacheWritePromise;
                }
              }));

              if (shouldBuffer) {
                // if the result fits in memory, use a collect stream to gather
                // the response and write it to cacache while also passing it through
                // to the user
                onResume = function onResume() {
                  var collector = new MinipassCollect.PassThrough();
                  abortStream = collector;
                  collector.on('collect', function (data) {
                    // TODO if the cache write fails, log a warning but return the response anyway
                    cacache.put(_this.options.cachePath, _this.key, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject);
                  });
                  body.unshift(collector);
                  body.unshift(_this.response.body);
                };
              } else {
                // if it does not fit in memory, create a tee stream and use
                // that to pipe to both the cache and the user simultaneously
                onResume = function onResume() {
                  var tee = new Minipass();
                  var cacheStream = cacache.put.stream(_this.options.cachePath, _this.key, cacheOpts);
                  abortStream = cacheStream;
                  tee.pipe(cacheStream); // TODO if the cache write fails, log a warning but return the response anyway

                  cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);
                  body.unshift(tee);
                  body.unshift(_this.response.body);
                };
              }

              body.once('resume', onResume);
              body.once('end', function () {
                return body.removeListener('resume', onResume);
              });
              this.response.body.on('error', function (err) {
                // the abortStream will either be a MinipassCollect if we buffer
                // or a cacache write stream, either way be sure to listen for
                // errors from the actual response and avoid writing data that we
                // know to be invalid to the cache
                abortStream.destroy(err);
              });
              _context.next = 19;
              break;

            case 17:
              _context.next = 19;
              return regeneratorRuntime.awrap(cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts));

            case 19:
              // note: we do not set the x-local-cache-hash header because we do not know
              // the hash value until after the write to the cache completes, which doesn't
              // happen until after the response has been sent and it's too late to write
              // the header anyway
              this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));
              this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key));
              this.response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');
              this.response.headers.set('x-local-cache-status', status);
              this.response.headers.set('x-local-cache-time', new Date().toISOString());
              newResponse = new Response(body, {
                url: this.response.url,
                status: this.response.status,
                headers: this.response.headers,
                counter: this.options.counter
              });
              return _context.abrupt("return", newResponse);

            case 26:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    } // use the cached data to create a response and return it

  }, {
    key: "respond",
    value: function respond(method, options, status) {
      var _this2 = this;

      var response, size, fitsInMemory, shouldBuffer, body, removeOnResume, onResume;
      return regeneratorRuntime.async(function respond$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              size = Number(this.response.headers.get('content-length'));
              fitsInMemory = !!size && size < MAX_MEM_SIZE;
              shouldBuffer = this.options.memoize !== false && fitsInMemory;

              if (method === 'HEAD' || [301, 308].includes(this.response.status)) {
                // if the request is a HEAD, or the response is a redirect,
                // then the metadata in the entry already includes everything
                // we need to build a response
                response = this.response;
              } else {
                // we're responding with a full cached response, so create a body
                // that reads from cacache and attach it to a new Response
                body = new Minipass();

                removeOnResume = function removeOnResume() {
                  return body.removeListener('resume', onResume);
                };

                if (shouldBuffer) {
                  onResume = function onResume() {
                    var content;
                    return regeneratorRuntime.async(function onResume$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            removeOnResume();
                            _context2.prev = 1;
                            _context2.next = 4;
                            return regeneratorRuntime.awrap(cacache.get.byDigest(_this2.options.cachePath, _this2.entry.integrity, {
                              memoize: _this2.options.memoize
                            }));

                          case 4:
                            content = _context2.sent;
                            body.end(content);
                            _context2.next = 17;
                            break;

                          case 8:
                            _context2.prev = 8;
                            _context2.t0 = _context2["catch"](1);

                            if (!(_context2.t0.code === 'EINTEGRITY')) {
                              _context2.next = 13;
                              break;
                            }

                            _context2.next = 13;
                            return regeneratorRuntime.awrap(cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {
                              memoize: _this2.options.memoize
                            }));

                          case 13:
                            if (!(_context2.t0.code === 'ENOENT' || _context2.t0.code === 'EINTEGRITY')) {
                              _context2.next = 16;
                              break;
                            }

                            _context2.next = 16;
                            return regeneratorRuntime.awrap(CacheEntry.invalidate(_this2.request, _this2.options));

                          case 16:
                            body.emit('error', _context2.t0);

                          case 17:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, null, null, [[1, 8]]);
                  };
                } else {
                  onResume = function onResume() {
                    var cacheStream = cacache.get.stream.byDigest(_this2.options.cachePath, _this2.entry.integrity, {
                      memoize: _this2.options.memoize
                    });
                    cacheStream.on('error', function _callee(err) {
                      return regeneratorRuntime.async(function _callee$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              cacheStream.pause();

                              if (!(err.code === 'EINTEGRITY')) {
                                _context3.next = 4;
                                break;
                              }

                              _context3.next = 4;
                              return regeneratorRuntime.awrap(cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {
                                memoize: _this2.options.memoize
                              }));

                            case 4:
                              if (!(err.code === 'ENOENT' || err.code === 'EINTEGRITY')) {
                                _context3.next = 7;
                                break;
                              }

                              _context3.next = 7;
                              return regeneratorRuntime.awrap(CacheEntry.invalidate(_this2.request, _this2.options));

                            case 7:
                              body.emit('error', err);
                              cacheStream.resume();

                            case 9:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      });
                    });
                    cacheStream.pipe(body);
                  };
                }

                body.once('resume', onResume);
                body.once('end', removeOnResume);
                response = new Response(body, {
                  url: this.entry.metadata.url,
                  counter: options.counter,
                  status: 200,
                  headers: _objectSpread({}, this.policy.responseHeaders())
                });
              }

              response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));
              response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity));
              response.headers.set('x-local-cache-key', encodeURIComponent(this.key));
              response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');
              response.headers.set('x-local-cache-status', status);
              response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString());
              return _context4.abrupt("return", response);

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    } // use the provided request along with this cache entry to
    // revalidate the stored response. returns a response, either
    // from the cache or from the update

  }, {
    key: "revalidate",
    value: function revalidate(request, options) {
      var revalidateRequest, response, metadata, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, name, newEntry;

      return regeneratorRuntime.async(function revalidate$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              revalidateRequest = new Request(request, {
                headers: this.policy.revalidationHeaders(request)
              });
              _context5.prev = 1;
              _context5.next = 4;
              return regeneratorRuntime.awrap(remote(revalidateRequest, _objectSpread({}, options, {
                headers: undefined
              })));

            case 4:
              response = _context5.sent;
              _context5.next = 12;
              break;

            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5["catch"](1);

              if (this.policy.mustRevalidate) {
                _context5.next = 11;
                break;
              }

              return _context5.abrupt("return", this.respond(request.method, options, 'stale'));

            case 11:
              throw _context5.t0;

            case 12:
              if (!this.policy.revalidated(revalidateRequest, response)) {
                _context5.next = 41;
                break;
              }

              // we got a 304, write a new index to the cache and respond from cache
              metadata = getMetadata(request, response, options); // 304 responses do not include headers that are specific to the response data
              // since they do not include a body, so we copy values for headers that were
              // in the old cache entry to the new one, if the new metadata does not already
              // include that header

              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context5.prev = 17;

              for (_iterator4 = KEEP_RESPONSE_HEADERS[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                name = _step4.value;
                if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name)) metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];
              }

              _context5.next = 25;
              break;

            case 21:
              _context5.prev = 21;
              _context5.t1 = _context5["catch"](17);
              _didIteratorError4 = true;
              _iteratorError4 = _context5.t1;

            case 25:
              _context5.prev = 25;
              _context5.prev = 26;

              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }

            case 28:
              _context5.prev = 28;

              if (!_didIteratorError4) {
                _context5.next = 31;
                break;
              }

              throw _iteratorError4;

            case 31:
              return _context5.finish(28);

            case 32:
              return _context5.finish(25);

            case 33:
              _context5.prev = 33;
              _context5.next = 36;
              return regeneratorRuntime.awrap(cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {
                size: this.entry.size,
                metadata: metadata
              }));

            case 36:
              _context5.next = 40;
              break;

            case 38:
              _context5.prev = 38;
              _context5.t2 = _context5["catch"](33);

            case 40:
              return _context5.abrupt("return", this.respond(request.method, options, 'revalidated'));

            case 41:
              // if we got a modified response, create a new entry based on it
              newEntry = new CacheEntry({
                request: request,
                response: response,
                options: options
              }); // respond with the new entry while writing it to the cache

              return _context5.abrupt("return", newEntry.store('updated'));

            case 43:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this, [[1, 7], [17, 21, 25, 33], [26,, 28, 32], [33, 38]]);
    }
  }, {
    key: "request",
    get: function get() {
      if (!this[_request]) {
        this[_request] = new Request(this.entry.metadata.url, {
          method: 'GET',
          headers: this.entry.metadata.reqHeaders
        });
      }

      return this[_request];
    }
  }, {
    key: "response",
    get: function get() {
      if (!this[_response]) {
        this[_response] = new Response(null, {
          url: this.entry.metadata.url,
          counter: this.options.counter,
          status: this.entry.metadata.status || 200,
          headers: _objectSpread({}, this.entry.metadata.resHeaders, {
            'content-length': this.entry.size
          })
        });
      }

      return this[_response];
    }
  }, {
    key: "policy",
    get: function get() {
      if (!this[_policy]) {
        this[_policy] = new CachePolicy({
          entry: this.entry,
          request: this.request,
          response: this.response,
          options: this.options
        });
      }

      return this[_policy];
    }
  }], [{
    key: "find",
    value: function find(request, options) {
      var matches, match, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, entry, _entry;

      return regeneratorRuntime.async(function find$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return regeneratorRuntime.awrap(cacache.index.compact(options.cachePath, cacheKey(request), function (A, B) {
                var entryA = new CacheEntry({
                  entry: A,
                  options: options
                });
                var entryB = new CacheEntry({
                  entry: B,
                  options: options
                });
                return entryA.policy.satisfies(entryB.request);
              }, {
                validateEntry: function validateEntry(entry) {
                  // if an integrity is null, it needs to have a status specified
                  if (entry.integrity === null) return !!(entry.metadata && entry.metadata.status);
                  return true;
                }
              }));

            case 3:
              matches = _context6.sent;
              _context6.next = 9;
              break;

            case 6:
              _context6.prev = 6;
              _context6.t0 = _context6["catch"](0);
              return _context6.abrupt("return");

            case 9:
              if (!(options.cache === 'reload')) {
                _context6.next = 11;
                break;
              }

              return _context6.abrupt("return");

            case 11:
              _iteratorNormalCompletion5 = true;
              _didIteratorError5 = false;
              _iteratorError5 = undefined;
              _context6.prev = 14;
              _iterator5 = matches[Symbol.iterator]();

            case 16:
              if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                _context6.next = 25;
                break;
              }

              entry = _step5.value;
              _entry = new CacheEntry({
                entry: entry,
                options: options
              });

              if (!_entry.policy.satisfies(request)) {
                _context6.next = 22;
                break;
              }

              match = _entry;
              return _context6.abrupt("break", 25);

            case 22:
              _iteratorNormalCompletion5 = true;
              _context6.next = 16;
              break;

            case 25:
              _context6.next = 31;
              break;

            case 27:
              _context6.prev = 27;
              _context6.t1 = _context6["catch"](14);
              _didIteratorError5 = true;
              _iteratorError5 = _context6.t1;

            case 31:
              _context6.prev = 31;
              _context6.prev = 32;

              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }

            case 34:
              _context6.prev = 34;

              if (!_didIteratorError5) {
                _context6.next = 37;
                break;
              }

              throw _iteratorError5;

            case 37:
              return _context6.finish(34);

            case 38:
              return _context6.finish(31);

            case 39:
              return _context6.abrupt("return", match);

            case 40:
            case "end":
              return _context6.stop();
          }
        }
      }, null, null, [[0, 6], [14, 27, 31, 39], [32,, 34, 38]]);
    } // if the user made a PUT/POST/PATCH then we invalidate our
    // cache for the same url by deleting the index entirely

  }, {
    key: "invalidate",
    value: function invalidate(request, options) {
      var key;
      return regeneratorRuntime.async(function invalidate$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              key = cacheKey(request);
              _context7.prev = 1;
              _context7.next = 4;
              return regeneratorRuntime.awrap(cacache.rm.entry(options.cachePath, key, {
                removeFully: true
              }));

            case 4:
              _context7.next = 8;
              break;

            case 6:
              _context7.prev = 6;
              _context7.t0 = _context7["catch"](1);

            case 8:
            case "end":
              return _context7.stop();
          }
        }
      }, null, null, [[1, 6]]);
    }
  }]);

  return CacheEntry;
}();

module.exports = CacheEntry;