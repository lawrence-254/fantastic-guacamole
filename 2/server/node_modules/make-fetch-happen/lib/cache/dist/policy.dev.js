"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var CacheSemantics = require('http-cache-semantics');

var Negotiator = require('negotiator');

var ssri = require('ssri'); // HACK: negotiator lazy loads several of its own modules
// as a micro optimization. we need to be sure that they're
// in memory as soon as possible at startup so that we do
// not try to lazy load them after the directory has been
// retired during a self update of the npm CLI, we do this
// by calling all of the methods that trigger a lazy load
// on a fake instance.


var preloadNegotiator = new Negotiator({
  headers: {}
});
preloadNegotiator.charsets();
preloadNegotiator.encodings();
preloadNegotiator.languages();
preloadNegotiator.mediaTypes(); // options passed to http-cache-semantics constructor

var policyOptions = {
  shared: false,
  ignoreCargoCult: true
}; // a fake empty response, used when only testing the
// request for storability

var emptyResponse = {
  status: 200,
  headers: {}
}; // returns a plain object representation of the Request

var requestObject = function requestObject(request) {
  var _obj = {
    method: request.method,
    url: request.url,
    headers: {}
  };
  request.headers.forEach(function (value, key) {
    _obj.headers[key] = value;
  });
  return _obj;
}; // returns a plain object representation of the Response


var responseObject = function responseObject(response) {
  var _obj = {
    status: response.status,
    headers: {}
  };
  response.headers.forEach(function (value, key) {
    _obj.headers[key] = value;
  });
  return _obj;
};

var CachePolicy =
/*#__PURE__*/
function () {
  function CachePolicy(_ref) {
    var entry = _ref.entry,
        request = _ref.request,
        response = _ref.response,
        options = _ref.options;

    _classCallCheck(this, CachePolicy);

    this.entry = entry;
    this.request = requestObject(request);
    this.response = responseObject(response);
    this.options = options;
    this.policy = new CacheSemantics(this.request, this.response, policyOptions);

    if (this.entry) {
      // if we have an entry, copy the timestamp to the _responseTime
      // this is necessary because the CacheSemantics constructor forces
      // the value to Date.now() which means a policy created from a
      // cache entry is likely to always identify itself as stale
      this.policy._responseTime = this.entry.metadata.time;
    }
  } // static method to quickly determine if a request alone is storable


  _createClass(CachePolicy, [{
    key: "satisfies",
    // returns true if the policy satisfies the request
    value: function satisfies(request) {
      var _req = requestObject(request);

      if (this.request.headers.host !== _req.headers.host) return false;
      var negotiatorA = new Negotiator(this.request);
      var negotiatorB = new Negotiator(_req);
      if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) return false;
      if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) return false;
      if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) return false;
      if (this.options.integrity) return ssri.parse(this.options.integrity).match(this.entry.integrity);
      return true;
    } // returns true if the request and response allow caching

  }, {
    key: "storable",
    value: function storable() {
      return this.policy.storable();
    } // NOTE: this is a hack to avoid parsing the cache-control
    // header ourselves, it returns true if the response's
    // cache-control contains must-revalidate

  }, {
    key: "needsRevalidation",
    // returns true if the cached response requires revalidation
    // for the given request
    value: function needsRevalidation(request) {
      var _req = requestObject(request); // force method to GET because we only cache GETs
      // but can serve a HEAD from a cached GET


      _req.method = 'GET';
      return !this.policy.satisfiesWithoutRevalidation(_req);
    }
  }, {
    key: "responseHeaders",
    value: function responseHeaders() {
      return this.policy.responseHeaders();
    } // returns a new object containing the appropriate headers
    // to send a revalidation request

  }, {
    key: "revalidationHeaders",
    value: function revalidationHeaders(request) {
      var _req = requestObject(request);

      return this.policy.revalidationHeaders(_req);
    } // returns true if the request/response was revalidated
    // successfully. returns false if a new response was received

  }, {
    key: "revalidated",
    value: function revalidated(request, response) {
      var _req = requestObject(request);

      var _res = responseObject(response);

      var policy = this.policy.revalidatedPolicy(_req, _res);
      return !policy.modified;
    }
  }, {
    key: "mustRevalidate",
    get: function get() {
      return !!this.policy._rescc['must-revalidate'];
    }
  }], [{
    key: "storable",
    value: function storable(request, options) {
      // no cachePath means no caching
      if (!options.cachePath) return false; // user explicitly asked not to cache

      if (options.cache === 'no-store') return false; // we only cache GET and HEAD requests

      if (!['GET', 'HEAD'].includes(request.method)) return false; // otherwise, let http-cache-semantics make the decision
      // based on the request's headers

      var policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);
      return policy.storable();
    }
  }]);

  return CachePolicy;
}();

module.exports = CachePolicy;