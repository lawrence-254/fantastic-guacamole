'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LRU = require('lru-cache');

var url = require('url');

var isLambda = require('is-lambda');

var AGENT_CACHE = new LRU({
  max: 50
});

var HttpAgent = require('agentkeepalive');

var HttpsAgent = HttpAgent.HttpsAgent;
module.exports = getAgent;

var getAgentTimeout = function getAgentTimeout(timeout) {
  return typeof timeout !== 'number' || !timeout ? 0 : timeout + 1;
};

var getMaxSockets = function getMaxSockets(maxSockets) {
  return maxSockets || 15;
};

function getAgent(uri, opts) {
  var parsedUri = new url.URL(typeof uri === 'string' ? uri : uri.url);
  var isHttps = parsedUri.protocol === 'https:';
  var pxuri = getProxyUri(parsedUri.href, opts); // If opts.timeout is zero, set the agentTimeout to zero as well. A timeout
  // of zero disables the timeout behavior (OS limits still apply). Else, if
  // opts.timeout is a non-zero value, set it to timeout + 1, to ensure that
  // the node-fetch-npm timeout will always fire first, giving us more
  // consistent errors.

  var agentTimeout = getAgentTimeout(opts.timeout);
  var agentMaxSockets = getMaxSockets(opts.maxSockets);
  var key = ["https:".concat(isHttps), pxuri ? "proxy:".concat(pxuri.protocol, "//").concat(pxuri.host, ":").concat(pxuri.port) : '>no-proxy<', "local-address:".concat(opts.localAddress || '>no-local-address<'), "strict-ssl:".concat(isHttps ? opts.rejectUnauthorized : '>no-strict-ssl<'), "ca:".concat(isHttps && opts.ca || '>no-ca<'), "cert:".concat(isHttps && opts.cert || '>no-cert<'), "key:".concat(isHttps && opts.key || '>no-key<'), "timeout:".concat(agentTimeout), "maxSockets:".concat(agentMaxSockets)].join(':');

  if (opts.agent != null) {
    // `agent: false` has special behavior!
    return opts.agent;
  } // keep alive in AWS lambda makes no sense


  var lambdaAgent = !isLambda ? null : isHttps ? require('https').globalAgent : require('http').globalAgent;
  if (isLambda && !pxuri) return lambdaAgent;
  if (AGENT_CACHE.peek(key)) return AGENT_CACHE.get(key);

  if (pxuri) {
    var pxopts = isLambda ? _objectSpread({}, opts, {
      agent: lambdaAgent
    }) : opts;
    var proxy = getProxy(pxuri, pxopts, isHttps);
    AGENT_CACHE.set(key, proxy);
    return proxy;
  }

  var agent = isHttps ? new HttpsAgent({
    maxSockets: agentMaxSockets,
    ca: opts.ca,
    cert: opts.cert,
    key: opts.key,
    localAddress: opts.localAddress,
    rejectUnauthorized: opts.rejectUnauthorized,
    timeout: agentTimeout
  }) : new HttpAgent({
    maxSockets: agentMaxSockets,
    localAddress: opts.localAddress,
    timeout: agentTimeout
  });
  AGENT_CACHE.set(key, agent);
  return agent;
}

function checkNoProxy(uri, opts) {
  var host = new url.URL(uri).hostname.split('.').reverse();
  var noproxy = opts.noProxy || getProcessEnv('no_proxy');
  if (typeof noproxy === 'string') noproxy = noproxy.split(/\s*,\s*/g);
  return noproxy && noproxy.some(function (no) {
    var noParts = no.split('.').filter(function (x) {
      return x;
    }).reverse();
    if (!noParts.length) return false;

    for (var i = 0; i < noParts.length; i++) {
      if (host[i] !== noParts[i]) return false;
    }

    return true;
  });
}

module.exports.getProcessEnv = getProcessEnv;

function getProcessEnv(env) {
  if (!env) return;
  var value;

  if (Array.isArray(env)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = env[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var e = _step.value;
        value = process.env[e] || process.env[e.toUpperCase()] || process.env[e.toLowerCase()];
        if (typeof value !== 'undefined') break;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (typeof env === 'string') {
    value = process.env[env] || process.env[env.toUpperCase()] || process.env[env.toLowerCase()];
  }

  return value;
}

module.exports.getProxyUri = getProxyUri;

function getProxyUri(uri, opts) {
  var protocol = new url.URL(uri).protocol;
  var proxy = opts.proxy || protocol === 'https:' && getProcessEnv('https_proxy') || protocol === 'http:' && getProcessEnv(['https_proxy', 'http_proxy', 'proxy']);
  if (!proxy) return null;
  var parsedProxy = typeof proxy === 'string' ? new url.URL(proxy) : proxy;
  return !checkNoProxy(uri, opts) && parsedProxy;
}

var getAuth = function getAuth(u) {
  return u.username && u.password ? decodeURIComponent("".concat(u.username, ":").concat(u.password)) : u.username ? decodeURIComponent(u.username) : null;
};

var getPath = function getPath(u) {
  return u.pathname + u.search + u.hash;
};

var HttpProxyAgent = require('http-proxy-agent');

var HttpsProxyAgent = require('https-proxy-agent');

var SocksProxyAgent = require('socks-proxy-agent');

module.exports.getProxy = getProxy;

function getProxy(proxyUrl, opts, isHttps) {
  var popts = {
    host: proxyUrl.hostname,
    port: proxyUrl.port,
    protocol: proxyUrl.protocol,
    path: getPath(proxyUrl),
    auth: getAuth(proxyUrl),
    ca: opts.ca,
    cert: opts.cert,
    key: opts.key,
    timeout: getAgentTimeout(opts.timeout),
    localAddress: opts.localAddress,
    maxSockets: getMaxSockets(opts.maxSockets),
    rejectUnauthorized: opts.rejectUnauthorized
  };

  if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {
    if (!isHttps) return new HttpProxyAgent(popts);else return new HttpsProxyAgent(popts);
  } else if (proxyUrl.protocol.startsWith('socks')) return new SocksProxyAgent(popts);else {
    throw Object.assign(new Error("unsupported proxy protocol: '".concat(proxyUrl.protocol, "'")), {
      url: proxyUrl.href
    });
  }
}