'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('minipass-fetch'),
    FetchError = _require.FetchError,
    Request = _require.Request,
    isRedirect = _require.isRedirect;

var url = require('url');

var CachePolicy = require('./cache/policy.js');

var cache = require('./cache/index.js');

var remote = require('./remote.js'); // given a Request, a Response and user options
// return true if the response is a redirect that
// can be followed. we throw errors that will result
// in the fetch being rejected if the redirect is
// possible but invalid for some reason


var canFollowRedirect = function canFollowRedirect(request, response, options) {
  if (!isRedirect(response.status)) return false;
  if (options.redirect === 'manual') return false;
  if (options.redirect === 'error') throw new FetchError("redirect mode is set to error: ".concat(request.url), 'no-redirect', {
    code: 'ENOREDIRECT'
  });
  if (!response.headers.has('location')) throw new FetchError("redirect location header missing for: ".concat(request.url), 'no-location', {
    code: 'EINVALIDREDIRECT'
  });
  if (request.counter >= request.follow) throw new FetchError("maximum redirect reached at: ".concat(request.url), 'max-redirect', {
    code: 'EMAXREDIRECT'
  });
  return true;
}; // given a Request, a Response, and the user's options return an object
// with a new Request and a new options object that will be used for
// following the redirect


var getRedirect = function getRedirect(request, response, options) {
  var _opts = _objectSpread({}, options);

  var location = response.headers.get('location');
  var redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url); // Comment below is used under the following license:
  // Copyright (c) 2010-2012 Mikeal Rogers
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  // http://www.apache.org/licenses/LICENSE-2.0
  // Unless required by applicable law or agreed to in writing,
  // software distributed under the License is distributed on an "AS
  // IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
  // express or implied. See the License for the specific language
  // governing permissions and limitations under the License.
  // Remove authorization if changing hostnames (but not if just
  // changing ports or protocols).  This matches the behavior of request:
  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138

  if (new url.URL(request.url).hostname !== redirectUrl.hostname) request.headers["delete"]('authorization'); // for POST request with 301/302 response, or any request with 303 response,
  // use GET when following redirect

  if (response.status === 303 || request.method === 'POST' && [301, 302].includes(response.status)) {
    _opts.method = 'GET';
    _opts.body = null;
    request.headers["delete"]('content-length');
  }

  _opts.headers = {};
  request.headers.forEach(function (value, key) {
    _opts.headers[key] = value;
  });
  _opts.counter = ++request.counter;
  var redirectReq = new Request(url.format(redirectUrl), _opts);
  return {
    request: redirectReq,
    options: _opts
  };
};

var fetch = function fetch(request, options) {
  var response, redirect;
  return regeneratorRuntime.async(function fetch$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!CachePolicy.storable(request, options)) {
            _context.next = 6;
            break;
          }

          _context.next = 3;
          return regeneratorRuntime.awrap(cache(request, options));

        case 3:
          _context.t0 = _context.sent;
          _context.next = 9;
          break;

        case 6:
          _context.next = 8;
          return regeneratorRuntime.awrap(remote(request, options));

        case 8:
          _context.t0 = _context.sent;

        case 9:
          response = _context.t0;

          if (!(!['GET', 'HEAD'].includes(request.method) && response.status >= 200 && response.status <= 399)) {
            _context.next = 13;
            break;
          }

          _context.next = 13;
          return regeneratorRuntime.awrap(cache.invalidate(request, options));

        case 13:
          if (canFollowRedirect(request, response, options)) {
            _context.next = 15;
            break;
          }

          return _context.abrupt("return", response);

        case 15:
          redirect = getRedirect(request, response, options);
          return _context.abrupt("return", fetch(redirect.request, redirect.options));

        case 17:
        case "end":
          return _context.stop();
      }
    }
  });
};

module.exports = fetch;