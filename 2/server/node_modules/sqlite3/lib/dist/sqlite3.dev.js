"use strict";

var path = require('path');

var sqlite3 = require('./sqlite3-binding.js');

var EventEmitter = require('events').EventEmitter;

module.exports = exports = sqlite3;

function normalizeMethod(fn) {
  return function (sql) {
    var errBack;
    var args = Array.prototype.slice.call(arguments, 1);

    if (typeof args[args.length - 1] === 'function') {
      var callback = args[args.length - 1];

      errBack = function errBack(err) {
        if (err) {
          callback(err);
        }
      };
    }

    var statement = new Statement(this, sql, errBack);
    return fn.call(this, statement, args);
  };
}

function inherits(target, source) {
  for (var k in source.prototype) {
    target.prototype[k] = source.prototype[k];
  }
}

sqlite3.cached = {
  Database: function Database(file, a, b) {
    if (file === '' || file === ':memory:') {
      // Don't cache special databases.
      return new _Database(file, a, b);
    }

    var db;
    file = path.resolve(file);

    if (!sqlite3.cached.objects[file]) {
      db = sqlite3.cached.objects[file] = new _Database(file, a, b);
    } else {
      // Make sure the callback is called.
      db = sqlite3.cached.objects[file];
      var callback = typeof a === 'number' ? b : a;

      if (typeof callback === 'function') {
        var cb = function cb() {
          callback.call(db, null);
        };

        if (db.open) process.nextTick(cb);else db.once('open', cb);
      }
    }

    return db;
  },
  objects: {}
};
var _Database = sqlite3.Database;
var Statement = sqlite3.Statement;
var Backup = sqlite3.Backup;
inherits(_Database, EventEmitter);
inherits(Statement, EventEmitter);
inherits(Backup, EventEmitter); // Database#prepare(sql, [bind1, bind2, ...], [callback])

_Database.prototype.prepare = normalizeMethod(function (statement, params) {
  return params.length ? statement.bind.apply(statement, params) : statement;
}); // Database#run(sql, [bind1, bind2, ...], [callback])

_Database.prototype.run = normalizeMethod(function (statement, params) {
  statement.run.apply(statement, params).finalize();
  return this;
}); // Database#get(sql, [bind1, bind2, ...], [callback])

_Database.prototype.get = normalizeMethod(function (statement, params) {
  statement.get.apply(statement, params).finalize();
  return this;
}); // Database#all(sql, [bind1, bind2, ...], [callback])

_Database.prototype.all = normalizeMethod(function (statement, params) {
  statement.all.apply(statement, params).finalize();
  return this;
}); // Database#each(sql, [bind1, bind2, ...], [callback], [complete])

_Database.prototype.each = normalizeMethod(function (statement, params) {
  statement.each.apply(statement, params).finalize();
  return this;
});
_Database.prototype.map = normalizeMethod(function (statement, params) {
  statement.map.apply(statement, params).finalize();
  return this;
}); // Database#backup(filename, [callback])
// Database#backup(filename, destName, sourceName, filenameIsDest, [callback])

_Database.prototype.backup = function () {
  var backup;

  if (arguments.length <= 2) {
    // By default, we write the main database out to the main database of the named file.
    // This is the most likely use of the backup api.
    backup = new Backup(this, arguments[0], 'main', 'main', true, arguments[1]);
  } else {
    // Otherwise, give the user full control over the sqlite3_backup_init arguments.
    backup = new Backup(this, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
  } // Per the sqlite docs, exclude the following errors as non-fatal by default.


  backup.retryErrors = [sqlite3.BUSY, sqlite3.LOCKED];
  return backup;
};

Statement.prototype.map = function () {
  var params = Array.prototype.slice.call(arguments);
  var callback = params.pop();
  params.push(function (err, rows) {
    if (err) return callback(err);
    var result = {};

    if (rows.length) {
      var keys = Object.keys(rows[0]);
      var key = keys[0];

      if (keys.length > 2) {
        // Value is an object
        for (var i = 0; i < rows.length; i++) {
          result[rows[i][key]] = rows[i];
        }
      } else {
        var value = keys[1]; // Value is a plain value

        for (var _i = 0; _i < rows.length; _i++) {
          result[rows[_i][key]] = rows[_i][value];
        }
      }
    }

    callback(err, result);
  });
  return this.all.apply(this, params);
};

var isVerbose = false;
var supportedEvents = ['trace', 'profile', 'change'];

_Database.prototype.addListener = _Database.prototype.on = function (type) {
  var val = EventEmitter.prototype.addListener.apply(this, arguments);

  if (supportedEvents.indexOf(type) >= 0) {
    this.configure(type, true);
  }

  return val;
};

_Database.prototype.removeListener = function (type) {
  var val = EventEmitter.prototype.removeListener.apply(this, arguments);

  if (supportedEvents.indexOf(type) >= 0 && !this._events[type]) {
    this.configure(type, false);
  }

  return val;
};

_Database.prototype.removeAllListeners = function (type) {
  var val = EventEmitter.prototype.removeAllListeners.apply(this, arguments);

  if (supportedEvents.indexOf(type) >= 0) {
    this.configure(type, false);
  }

  return val;
}; // Save the stack trace over EIO callbacks.


sqlite3.verbose = function () {
  if (!isVerbose) {
    var trace = require('./trace');

    ['prepare', 'get', 'run', 'all', 'each', 'map', 'close', 'exec'].forEach(function (name) {
      trace.extendTrace(_Database.prototype, name);
    });
    ['bind', 'get', 'run', 'all', 'each', 'map', 'reset', 'finalize'].forEach(function (name) {
      trace.extendTrace(Statement.prototype, name);
    });
    isVerbose = true;
  }

  return sqlite3;
};